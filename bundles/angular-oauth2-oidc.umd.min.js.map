{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://angular-oauth2-oidc/types.ts","ng://angular-oauth2-oidc/base64-helper.ts","ng://angular-oauth2-oidc/token-validation/validation-handler.ts","ng://angular-oauth2-oidc/url-helper.service.ts","ng://angular-oauth2-oidc/events.ts","ng://angular-oauth2-oidc/auth.config.ts","ng://angular-oauth2-oidc/encoder.ts","ng://angular-oauth2-oidc/token-validation/hash-handler.ts","ng://angular-oauth2-oidc/oauth-service.ts","ng://angular-oauth2-oidc/oauth-module.config.ts","ng://angular-oauth2-oidc/interceptors/resource-server-error-handler.ts","ng://angular-oauth2-oidc/interceptors/default-oauth.interceptor.ts","ng://angular-oauth2-oidc/token-validation/null-validation-handler.ts","ng://angular-oauth2-oidc/factories.ts","ng://angular-oauth2-oidc/angular-oauth-oidc.module.ts","ng://angular-oauth2-oidc/token-validation/jwks-validation-handler.ts","ng://angular-oauth2-oidc/tokens.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__metadata","metadataKey","metadataValue","metadata","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","n","v","op","TypeError","call","pop","push","__values","o","s","m","__read","ar","error","preventClearHashAfterLogin","MemoryStorage","data","Map","getItem","get","removeItem","delete","setItem","set","Injectable","b64DecodeUnicode","str","base64","replace","decodeURIComponent","atob","split","map","charCodeAt","toString","slice","join","base64UrlEncode","btoa","ValidationHandler","AbstractValidationHandler","validateAtHash","params","hashAlg","inferHashAlgorithm","idTokenHeader","calcHash","accessToken","tokenHash","_a","leftMostHalf","substr","atHash","claimsAtHash","idTokenClaims","console","jwtHeader","alg","match","Error","UrlHelperService","getHashFragmentParams","customHashFragment","hash","window","location","indexOf","questionMarkPosition","parseQueryString","queryString","pairs","pair","separatorIndex","escapedKey","escapedValue","type","OAuthSuccessEvent","info","_this","_super","OAuthEvent","OAuthInfoEvent","OAuthErrorEvent","reason","json","clientId","redirectUri","postLogoutRedirectUri","loginUrl","scope","resource","rngUrl","oidc","requestAccessToken","options","issuer","logoutUrl","clearHashAfterLogin","tokenEndpoint","customTokenParameters","userinfoEndpoint","responseType","showDebugInformation","silentRefreshRedirectUri","silentRefreshMessagePrefix","silentRefreshShowIFrame","siletRefreshTimeout","silentRefreshTimeout","dummyClientSecret","requireHttps","strictDiscoveryDocumentValidation","jwks","customQueryParams","silentRefreshIFrameName","timeoutFactor","sessionChecksEnabled","sessionCheckIntervall","sessionCheckIFrameUrl","sessionCheckIFrameName","disableAtHashCheck","skipSubjectCheck","useIdTokenHintForSilentRefresh","skipIssuerCheck","nonceStateSeparator","useHttpBasicAuth","waitForTokenInMsec","disablePKCE","openUri","uri","href","assign","WebHttpUrlEncodingCodec","encodeKey","k","encodeURIComponent","encodeValue","decodeKey","decodeValue","HashHandler","DefaultHashHandler","valueToHash","algorithm","encoder","TextEncoder","encode","crypto","subtle","digest","hashArray","toHashString","buffer","byteArray","Uint8Array","byteArray_1","byteArray_1_1","String","fromCharCode","OAuthService","ngZone","http","storage","tokenValidationHandler","config","urlHelper","logger","discoveryDocumentLoaded","state","eventsSubject","Subject","discoveryDocumentLoadedSubject","grantTypesSupported","inImplicitFlow","debug","discoveryDocumentLoaded$","asObservable","events","configure","setStorage","sessionStorage","setupRefreshTimer","AuthConfig","setupSessionCheck","configChanged","restartSessionChecksIfStillLoggedIn","hasValidIdToken","initSessionCheck","restartRefreshTimerIfStillLoggedIn","setupExpirationTimers","pipe","filter","subscribe","setupAutomaticSilentRefresh","listenTo","noPrompt","shouldRunSilentRefresh","tap","debounceTime","refreshInternal","catch","silentRefresh","refreshToken","loadDiscoveryDocumentAndTryLogin","loadDiscoveryDocument","doc","tryLogin","loadDiscoveryDocumentAndLogin","hasValidAccessToken","initCodeFlow","initImplicitFlow","args","_i","validateUrlFromDiscoveryDocument","url","errors","httpsCheck","validateUrlForHttps","issuerCheck","validateUrlAgainstIssuer","lcUrl","toLowerCase","startsWith","assertUrlNotNullAndCorrectProtocol","description","clearAccessTokenTimer","clearIdTokenTimer","tokenReceivedSubscription","unsubscribe","setupAccessTokenTimer","setupIdTokenTimer","expiration","getAccessTokenExpiration","storedAt","getAccessTokenStoredAt","timeout","calcTimeout","runOutsideAngular","accessTokenTimeoutSubscription","of","delay","run","getIdTokenExpiration","getIdTokenStoredAt","idTokenTimeoutSubscription","now","Date","delta","Math","max","_storage","fullUrl","endsWith","validateDiscoveryDocument","authorization_endpoint","end_session_endpoint","grant_types_supported","token_endpoint","userinfo_endpoint","jwksUri","jwks_uri","check_session_iframe","loadJwks","event","discoveryDocument","err","warn","fetchTokenUsingPasswordFlowAndLoadUserProfile","userName","password","headers","HttpHeaders","fetchTokenUsingPasswordFlow","loadUserProfile","getAccessToken","existingClaims","getIdentityClaims","sub","JSON","stringify","HttpParams","header","_b","getOwnPropertyNames","_c","post","tokenResponse","storeAccessTokenResponse","access_token","refresh_token","expires_in","extractRecognizedCustomParameters","switchMap","id_token","from","processIdToken","storeIdToken","removeSilentRefreshEventListener","silentRefreshPostMessageEventListener","removeEventListener","setupSilentRefreshEventListener","message","processMessageEventMessage","customRedirectUri","addEventListener","claims","getIdToken","document","existingIframe","getElementById","removeChild","silentRefreshSubject","iframe","createElement","id","createLoginUrl","setAttribute","style","appendChild","first","success","race","toPromise","initImplicitFlowInPopup","initLoginFlowInPopup","display","checkForPopupClosedTimer","windowRef","open","calculatePopupFeatures","setInterval","closed","cleanup","clearInterval","listener","close","log","height","width","left","screenLeft","outerWidth","screenTop","outerHeight","expectedPrefix","prefixedMessage","canPerformSessionCheck","getSessionState","setupSessionCheckEventListener","removeSessionCheckEventListener","sessionCheckEventListener","origin","handleSessionUnchanged","handleSessionChange","handleSessionError","stopSessionCheckTimer","waitForSilentRefreshAfterSessionChange","logOut","startSessionCheckTimer","sessionCheckTimer","checkSession","bind","sessionState","contentWindow","postMessage","loginHint","that","createAndSaveNonce","nonce","_h","seperationChar","createChallangeVerifierPairForPKCE","challenge","verifier","keys","_d","_e","initImplicitFlowInternal","additionalState","addParams","resetImplicitFlow","callOnTokenReceivedIfExists","onTokenReceived","tokenParams","idClaims","idToken","expiresIn","grantedScopes","customParameters","expiresInMilliSeconds","expiresAt","getTime","forEach","tryLoginCodeFlow","tryLoginImplicitFlow","charAt","substring","search","parts","getCodePartsFromUrl","code","history","replaceState","name","parseState","nonceInState","userState","handleLoginError","validateNonce","event_1","getTokenFromCode","pkciVerifier","fetchAndProcessToken","disableOAuth2StateCheck","event_2","fallbackAccessTokenExpirationTimeInSec","validationHandler","storeSessionState","idx","savedNonce","idTokenClaimsJson","idTokenExpiresAt","onLoginError","skipNonceCheck","tokenParts","headerJson","padBase64","parse","claimsJson","isArray","aud","every","iat","iss","issuedAtMSec","expiresAtMSec","exp","clockSkewInMSec","clockSkewInSec","validationParams","loadKeys","checkSignature","idTokenHeaderJson","checkAtHash","atHashValid","atHashCheckEnabled","getGrantedScopes","scopes","base64data","getRefreshToken","parseInt","getCustomTokenResponseProperty","requestedProperty","authorizationHeader","noRedirectToLogoutUrl","customParam","postLogoutUrl","createNonce","ngOnDestroy","silentRefreshFrame","remove","sessionCheckFrame","unreserved","size","self","bytes","getRandomValues","x","random","validateSignature","initLoginFlow","initCodeFlowInternal","challengeRaw","foundParameters","recognizedParameter","NgZone","HttpClient","OAuthStorage","Optional","OAuthLogger","OAuthNoopResourceServerErrorHandler","handleError","throwError","DefaultOAuthInterceptor","authStorage","oAuthService","errorHandler","moduleConfig","checkUrl","resourceServer","customUrlValidation","allowedUrls","find","u","intercept","req","sendAccessToken","merge","token","catchError","take","mergeMap","clone","handle","OAuthResourceServerErrorHandler","OAuthModuleConfig","NullValidationHandler","createDefaultLogger","createDefaultStorage","OAuthModule","forRoot","validationHandlerClass","ngModule","OAuthModule_1","providers","provide","useFactory","useClass","useValue","HTTP_INTERCEPTORS","multi","NgModule","imports","CommonModule","declarations","exports","JwksValidationHandler","AUTH_CONFIG","InjectionToken"],"mappings":";;;;;;;;;;;;;;oFAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IAGrB,SAASO,EAAUR,EAAGC,GAEzB,SAASQ,IAAOC,KAAKC,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEY,UAAkB,OAANX,EAAaC,OAAOW,OAAOZ,IAAMQ,EAAGG,UAAYX,EAAEW,UAAW,IAAIH,GA0B5E,SAASK,EAAWC,EAAYC,EAAQC,EAAKC,GAChD,IAA2HlB,EAAvHmB,EAAIC,UAAUC,OAAQC,EAAIH,EAAI,EAAIH,EAAkB,OAATE,EAAgBA,EAAOhB,OAAOqB,yBAAyBP,EAAQC,GAAOC,EACrH,GAAuB,iBAAZM,SAAoD,mBAArBA,QAAQC,SAAyBH,EAAIE,QAAQC,SAASV,EAAYC,EAAQC,EAAKC,QACpH,IAAK,IAAIQ,EAAIX,EAAWM,OAAS,EAAGK,GAAK,EAAGA,KAAS1B,EAAIe,EAAWW,MAAIJ,GAAKH,EAAI,EAAInB,EAAEsB,GAAKH,EAAI,EAAInB,EAAEgB,EAAQC,EAAKK,GAAKtB,EAAEgB,EAAQC,KAASK,GAChJ,OAAOH,EAAI,GAAKG,GAAKpB,OAAOyB,eAAeX,EAAQC,EAAKK,GAAIA,EAGzD,SAASM,EAAQC,EAAYC,GAChC,OAAO,SAAUd,EAAQC,GAAOa,EAAUd,EAAQC,EAAKY,IAGpD,SAASE,EAAWC,EAAaC,GACpC,GAAuB,iBAAZT,SAAoD,mBAArBA,QAAQU,SAAyB,OAAOV,QAAQU,SAASF,EAAaC,GAG7G,SAASE,EAAUC,EAASC,EAAYC,EAAGC,GAE9C,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,IAAW,MAAOG,GAAKL,EAAOK,IACpF,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,IAAW,MAAOG,GAAKL,EAAOK,IACvF,SAASF,EAAKI,GAJlB,IAAeL,EAIaK,EAAOC,KAAOT,EAAQQ,EAAOL,QAJ1CA,EAIyDK,EAAOL,MAJhDA,aAAiBN,EAAIM,EAAQ,IAAIN,GAAE,SAAUG,GAAWA,EAAQG,OAITO,KAAKR,EAAWK,GAClGH,GAAMN,EAAYA,EAAUa,MAAMhB,EAASC,GAAc,KAAKS,WAI/D,SAASO,EAAYjB,EAASkB,GACjC,IAAsGC,EAAGC,EAAGC,EAAGC,EAA3GC,EAAI,CAAEC,MAAO,EAAGC,KAAM,WAAa,GAAW,EAAPJ,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,IAAOK,KAAM,GAAIC,IAAK,IAChG,OAAOL,EAAI,CAAEZ,KAAMkB,EAAK,GAAIC,MAASD,EAAK,GAAIE,OAAUF,EAAK,IAAwB,mBAAXG,SAA0BT,EAAES,OAAOC,UAAY,WAAa,OAAO1D,OAAUgD,EACvJ,SAASM,EAAKK,GAAK,OAAO,SAAUC,GAAK,OACzC,SAAcC,GACV,GAAIhB,EAAG,MAAM,IAAIiB,UAAU,mCAC3B,KAAOb,GAAG,IACN,GAAIJ,EAAI,EAAGC,IAAMC,EAAY,EAARc,EAAG,GAASf,EAAU,OAAIe,EAAG,GAAKf,EAAS,SAAOC,EAAID,EAAU,SAAMC,EAAEgB,KAAKjB,GAAI,GAAKA,EAAEV,SAAWW,EAAIA,EAAEgB,KAAKjB,EAAGe,EAAG,KAAKrB,KAAM,OAAOO,EAE3J,OADID,EAAI,EAAGC,IAAGc,EAAK,CAAS,EAARA,EAAG,GAAQd,EAAEb,QACzB2B,EAAG,IACP,KAAK,EAAG,KAAK,EAAGd,EAAIc,EAAI,MACxB,KAAK,EAAc,OAAXZ,EAAEC,QAAgB,CAAEhB,MAAO2B,EAAG,GAAIrB,MAAM,GAChD,KAAK,EAAGS,EAAEC,QAASJ,EAAIe,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKZ,EAAEI,IAAIW,MAAOf,EAAEG,KAAKY,MAAO,SACxC,QACI,KAAkBjB,GAAZA,EAAIE,EAAEG,MAAYzC,OAAS,GAAKoC,EAAEA,EAAEpC,OAAS,MAAkB,IAAVkD,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAEZ,EAAI,EAAG,SACjG,GAAc,IAAVY,EAAG,MAAcd,GAAMc,EAAG,GAAKd,EAAE,IAAMc,EAAG,GAAKd,EAAE,IAAM,CAAEE,EAAEC,MAAQW,EAAG,GAAI,MAC9E,GAAc,IAAVA,EAAG,IAAYZ,EAAEC,MAAQH,EAAE,GAAI,CAAEE,EAAEC,MAAQH,EAAE,GAAIA,EAAIc,EAAI,MAC7D,GAAId,GAAKE,EAAEC,MAAQH,EAAE,GAAI,CAAEE,EAAEC,MAAQH,EAAE,GAAIE,EAAEI,IAAIY,KAAKJ,GAAK,MACvDd,EAAE,IAAIE,EAAEI,IAAIW,MAChBf,EAAEG,KAAKY,MAAO,SAEtBH,EAAKjB,EAAKmB,KAAKrC,EAASuB,GAC1B,MAAOZ,GAAKwB,EAAK,CAAC,EAAGxB,GAAIS,EAAI,EAAI,QAAWD,EAAIE,EAAI,EACtD,GAAY,EAARc,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAE3B,MAAO2B,EAAG,GAAKA,EAAG,QAAK,EAAQrB,MAAM,GArB9BL,CAAK,CAACwB,EAAGC,MA6BtD,SAASM,EAASC,GACrB,IAAIC,EAAsB,mBAAXX,QAAyBA,OAAOC,SAAUW,EAAID,GAAKD,EAAEC,GAAIpD,EAAI,EAC5E,GAAIqD,EAAG,OAAOA,EAAEN,KAAKI,GACrB,GAAIA,GAAyB,iBAAbA,EAAExD,OAAqB,MAAO,CAC1CyB,KAAM,WAEF,OADI+B,GAAKnD,GAAKmD,EAAExD,SAAQwD,OAAI,GACrB,CAAEjC,MAAOiC,GAAKA,EAAEnD,KAAMwB,MAAO2B,KAG5C,MAAM,IAAIL,UAAUM,EAAI,0BAA4B,mCAGjD,SAASE,EAAOH,EAAGR,GACtB,IAAIU,EAAsB,mBAAXZ,QAAyBU,EAAEV,OAAOC,UACjD,IAAKW,EAAG,OAAOF,EACf,IAAmBvD,EAAYyB,EAA3BrB,EAAIqD,EAAEN,KAAKI,GAAOI,EAAK,GAC3B,IACI,WAAc,IAANZ,GAAgBA,KAAM,MAAQ/C,EAAII,EAAEoB,QAAQI,MAAM+B,EAAGN,KAAKrD,EAAEsB,OAExE,MAAOsC,GAASnC,EAAI,CAAEmC,MAAOA,GACjC,QACQ,IACQ5D,IAAMA,EAAE4B,OAAS6B,EAAIrD,EAAU,SAAIqD,EAAEN,KAAK/C,GAE1D,QAAkB,GAAIqB,EAAG,MAAMA,EAAEmC,OAE7B,OAAOD,QClIX,WAoDEvE,KAAAyE,4BAA8B,KAgBhC,eAcA,0BAOA,SAAAC,IACU1E,KAAA2E,KAAO,IAAIC,IAcrB,OAZEF,EAAAxE,UAAA2E,QAAA,SAAQtE,GACN,OAAOP,KAAK2E,KAAKG,IAAIvE,IAGvBmE,EAAAxE,UAAA6E,WAAA,SAAWxE,GACTP,KAAK2E,KAAKK,OAAOzE,IAGnBmE,EAAAxE,UAAA+E,QAAA,SAAQ1E,EAAaoE,GACnB3E,KAAK2E,KAAKO,IAAI3E,EAAKoE,IAZVD,EAAatE,EAAA,CADzB+E,EAAAA,cACYT,QAqBb,aClHA,SAAgBU,EAAiBC,GAC/B,IAAMC,EAASD,EAAIE,QAAQ,MAAO,KAAKA,QAAQ,MAAO,KAEtD,OAAOC,mBACLC,KAAKH,GACFI,MAAM,IACNC,KAAI,SAASlF,GACZ,MAAO,KAAO,KAAOA,EAAEmF,WAAW,GAAGC,SAAS,KAAKC,OAAO,MAE3DC,KAAK,KAIZ,SAAgBC,EAAgBX,GAE9B,OADeY,KAAKZ,GAEjBE,QAAQ,MAAO,KACfA,QAAQ,MAAO,KACfA,QAAQ,KAAM,ICJnB,IAAAW,EAAA,aAmBAC,EAAA,WAAA,SAAAA,KAoDA,OA3CQA,EAAAjG,UAAAkG,eAAN,SAAqBC,2GAGH,OAFZC,EAAUtG,KAAKuG,mBAAmBF,EAAOG,eAE7B,CAAA,EAAMxG,KAAKyG,SAASJ,EAAOK,YAAaJ,WAaxD,OAbIK,EAAYC,EAAAzD,OAEZ0D,EAAeF,EAAUG,OAAO,EAAGH,EAAUhG,OAAS,GAEtDoG,EAASf,EAAgBa,GAEzBG,EAAeX,EAAOY,cAAuB,QAAE1B,QAAQ,KAAM,IAE7DwB,IAAWC,IACbE,QAAQ1C,MAAM,sBAAwBuC,GACtCG,QAAQ1C,MAAM,mBAAqBwC,IAGrC,CAAA,EAAOD,IAAWC,WASVb,EAAAjG,UAAAqG,mBAAV,SAA6BY,GAC3B,IAAIC,EAAcD,EAAe,IAEjC,IAAKC,EAAIC,MAAM,gBACb,MAAM,IAAIC,MAAM,4BAA8BF,GAGhD,MAAO,OAASA,EAAIN,OAAO,IAW/BX,EApDA,gBC/BA,SAAAoB,KA4DA,OA3DSA,EAAArH,UAAAsH,sBAAP,SAA6BC,GAC3B,IAAIC,EAAOD,GAAsBE,OAAOC,SAASF,KAIjD,GAA0B,KAF1BA,EAAOlC,mBAAmBkC,IAEjBG,QAAQ,KACf,MAAO,GAGT,IAAMC,EAAuBJ,EAAKG,QAAQ,KAQ1C,OALEH,EADEI,GAAwB,EACnBJ,EAAKZ,OAAOgB,EAAuB,GAEnCJ,EAAKZ,OAAO,GAGd9G,KAAK+H,iBAAiBL,IAGxBH,EAAArH,UAAA6H,iBAAP,SAAwBC,GACtB,IAEEC,EACAC,EACAC,EACAC,EACAC,EACA9H,EACA2B,EARIyC,EAAO,GAUb,GAAoB,OAAhBqD,EACF,OAAOrD,EAGTsD,EAAQD,EAAYtC,MAAM,KAE1B,IAAK,IAAI1E,EAAI,EAAGA,EAAIiH,EAAMtH,OAAQK,KAIR,KAFxBmH,GADAD,EAAOD,EAAMjH,IACS6G,QAAQ,OAG5BO,EAAaF,EACbG,EAAe,OAEfD,EAAaF,EAAKpB,OAAO,EAAGqB,GAC5BE,EAAeH,EAAKpB,OAAOqB,EAAiB,IAG9C5H,EAAMiF,mBAAmB4C,GACzBlG,EAAQsD,mBAAmB6C,GAEF,MAArB9H,EAAIuG,OAAO,EAAG,KAAcvG,EAAMA,EAAIuG,OAAO,IAEjDnC,EAAKpE,GAAO2B,EAGd,OAAOyC,GA1DE4C,EAAgBnH,EAAA,CAD5B+E,EAAAA,cACYoC,QCuBX,SAAqBe,GAAAtI,KAAAsI,KAAAA,iBAIrB,SAAAC,EAAYD,EAA0BE,QAAA,IAAAA,IAAAA,EAAA,MAAtC,IAAAC,EACEC,EAAA3E,KAAA/D,KAAMsI,IAAKtI,YADyByI,EAAAD,KAAAA,IAGxC,OAJuC1I,EAAAyI,EAAAG,GAIvCH,GAJuCI,iBAOrC,SAAAC,EAAYN,EAA0BE,QAAA,IAAAA,IAAAA,EAAA,MAAtC,IAAAC,EACEC,EAAA3E,KAAA/D,KAAMsI,IAAKtI,YADyByI,EAAAD,KAAAA,IAGxC,OAJoC1I,EAAA8I,EAAAF,GAIpCE,GAJoCD,iBAOlC,SAAAE,EACEP,EACSQ,EACAzC,QAAA,IAAAA,IAAAA,EAAA,MAHX,IAAAoC,EAKEC,EAAA3E,KAAA/D,KAAMsI,IAAKtI,YAHFyI,EAAAK,OAAAA,EACAL,EAAApC,OAAAA,IAIb,OARqCvG,EAAA+I,EAAAH,GAQrCG,GARqCF,KCuMnC,SAAYI,GA5OL/I,KAAAgJ,SAAY,GAKZhJ,KAAAiJ,YAAe,GAMfjJ,KAAAkJ,sBAAyB,GAMzBlJ,KAAAmJ,SAAY,GAKZnJ,KAAAoJ,MAAS,iBAETpJ,KAAAqJ,SAAY,GAEZrJ,KAAAsJ,OAAU,GAMVtJ,KAAAuJ,MAAQ,EAMRvJ,KAAAwJ,oBAAsB,EAEtBxJ,KAAAyJ,QAAgB,KAKhBzJ,KAAA0J,OAAU,GAKV1J,KAAA2J,UAAa,GAKb3J,KAAA4J,qBAAuB,EAKvB5J,KAAA6J,cAAyB,KAKzB7J,KAAA8J,sBAAmC,GAKnC9J,KAAA+J,iBAA4B,KAE5B/J,KAAAgK,aAAgB,GAQfhK,KAAAiK,sBAAwB,EAKzBjK,KAAAkK,yBAA4B,GAE5BlK,KAAAmK,2BAA8B,GAM9BnK,KAAAoK,yBAA2B,EAO3BpK,KAAAqK,oBAA+B,IAK/BrK,KAAAsK,qBAAgC,IAUhCtK,KAAAuK,kBAA6B,KAQ7BvK,KAAAwK,aAAwC,aAMxCxK,KAAAyK,mCAAqC,EAOrCzK,KAAA0K,KAAgB,KAMhB1K,KAAA2K,kBAA6B,KAE7B3K,KAAA4K,wBAA2B,2CAO3B5K,KAAA6K,cAAiB,IAOjB7K,KAAA8K,sBAAwB,EAMxB9K,KAAA+K,sBAAyB,IAKzB/K,KAAAgL,sBAAiC,KAKjChL,KAAAiL,uBAA0B,0CAS1BjL,KAAAkL,oBAAsB,EAMtBlL,KAAAmL,kBAAoB,EAEpBnL,KAAAoL,gCAAkC,EAMlCpL,KAAAqL,iBAAmB,EAenBrL,KAAAsL,oBAAuB,IAKvBtL,KAAAuL,kBAAoB,EAUpBvL,KAAAwL,mBAAsB,EAOtBxL,KAAAyL,aAAe,EAafzL,KAAA0L,QAAoC,SAAAC,GACzC/D,SAASgE,KAAOD,GAXZ5C,GACFvJ,OAAOqM,OAAO7L,KAAM+I,IC9O1B+C,EAAA,WAAA,SAAAA,KAgBA,OAfEA,EAAA5L,UAAA6L,UAAA,SAAUC,GACR,OAAOC,mBAAmBD,IAG5BF,EAAA5L,UAAAgM,YAAA,SAAYtI,GACV,OAAOqI,mBAAmBrI,IAG5BkI,EAAA5L,UAAAiM,UAAA,SAAUH,GACR,OAAOxG,mBAAmBwG,IAG5BF,EAAA5L,UAAAkM,YAAA,SAAYxI,GACV,OAAO4B,mBAAmB5B,IAE9BkI,EAhBA,GCCAO,EAAA,0BAKA,SAAAC,KAuCA,OArCUA,EAAApM,UAAAuG,SAAN,SAAe8F,EAAqBC,uGAGd,OAFZC,EAAU,IAAIC,YACd/H,EAAO8H,EAAQE,OAAOJ,GACV,CAAA,EAAM5E,OAAOiF,OAAOC,OAAOC,OAAON,EAAW7H,WAC/D,OADMoI,EAAYnG,EAAAzD,OAClB,CAAA,EAAOnD,KAAKgN,aAAaD,YAG7BT,EAAApM,UAAA8M,aAAA,SAAaC,WACLC,EAAY,IAAIC,WAAWF,GAC7B1K,EAAS,OACb,IAAc,IAAA6K,EAAAlJ,EAAAgJ,GAASG,EAAAD,EAAAhL,QAAAiL,EAAA7K,KAAA6K,EAAAD,EAAAhL,OAAE,CAApB,IAAIC,EAACgL,EAAAnL,MACRK,GAAU+K,OAAOC,aAAalL,qGAEhC,OAAOE,GAfA+J,EAAkBlM,EAAA,CAD9B+E,EAAAA,cACYmH,MC0BbkB,EAAA,SAAA9E,GAgDI,SAAA8E,EACcC,EACAC,EACEC,EACAC,EACUC,EACZC,EACAC,EACYnB,GAR1B,IAAAnE,EAUIC,EAAA3E,KAAA/D,OAAOA,KATGyI,EAAAgF,OAAAA,EACAhF,EAAAiF,KAAAA,EAGYjF,EAAAoF,OAAAA,EACZpF,EAAAqF,UAAAA,EACArF,EAAAsF,OAAAA,EACYtF,EAAAmE,OAAAA,EA1CnBnE,EAAAuF,yBAA0B,EAkB1BvF,EAAAwF,MAAQ,GAELxF,EAAAyF,cAAqC,IAAIC,EAAAA,QACzC1F,EAAA2F,+BAA4D,IAAID,EAAAA,QAEhE1F,EAAA4F,oBAAqC,GASrC5F,EAAA6F,gBAAiB,EAcvB7F,EAAK8F,MAAM,+BAEX9F,EAAK+F,yBAA2B/F,EAAK2F,+BAA+BK,eACpEhG,EAAKiG,OAASjG,EAAKyF,cAAcO,eAE7Bb,IACAnF,EAAKmF,uBAAyBA,GAG9BC,GACApF,EAAKkG,UAAUd,GAGnB,IACQF,EACAlF,EAAKmG,WAAWjB,GACiB,oBAAnBkB,gBACdpG,EAAKmG,WAAWC,gBAEtB,MAAOxM,GAEL6E,QAAQ1C,MACJ,8IAEAnC,UAIRoG,EAAKqG,sBA6qEb,OArwEkChP,EAAA0N,EAAA9E,GA+FvB8E,EAAAtN,UAAAyO,UAAP,SAAiBd,GAGbrO,OAAOqM,OAAO7L,KAAM,IAAI+O,EAAclB,GAEtC7N,KAAK6N,OAASrO,OAAOqM,OAAO,GAAkB,IAAIkD,EAAclB,GAE5D7N,KAAK8K,sBACL9K,KAAKgP,oBAGThP,KAAKiP,iBAGCzB,EAAAtN,UAAA+O,cAAV,WACIjP,KAAK8O,qBAGFtB,EAAAtN,UAAAgP,oCAAP,WACQlP,KAAKmP,mBACLnP,KAAKoP,oBAIH5B,EAAAtN,UAAAmP,mCAAV,WACIrP,KAAKsP,yBAGC9B,EAAAtN,UAAA8O,kBAAV,WAAA,IAAAvG,EAAAzI,KACIA,KAAK0O,OAAOa,KAAKC,EAAAA,QAAO,SAAAnN,GAAK,MAAW,mBAAXA,EAAEiG,SAA4BmH,WAAU,SAAApN,GACjEoG,EAAK2G,uBAYN5B,EAAAtN,UAAAwP,4BAAP,SAAmCrJ,EAAqBsJ,EAAgDC,GAAxG,IAAAnH,EAAAzI,UAAmC,IAAAqG,IAAAA,EAAA,SAAqE,IAAAuJ,IAAAA,GAAA,GACpG,IAAIC,GAAyB,EAC7B7P,KAAK0O,OAAOa,KACRO,EAAAA,KAAI,SAACzN,GACc,mBAAXA,EAAEiG,KACFuH,GAAyB,EACP,WAAXxN,EAAEiG,OACTuH,GAAyB,MAGjCL,EAAAA,QAAO,SAAAnN,GAAK,MAAW,kBAAXA,EAAEiG,QACdyH,EAAAA,aAAa,MACfN,WAAU,SAAApN,GAES,MAAZsN,GAAiC,QAAbA,GADXtN,EACuCmG,OAASmH,IAAaE,GAEvEpH,EAAKuH,gBAAgB3J,EAAQuJ,GAAUK,OAAM,SAAAhN,GACzCwF,EAAK8F,MAAM,+CAKvBvO,KAAKqP,sCAGC7B,EAAAtN,UAAA8P,gBAAV,SAA0B3J,EAAQuJ,GAE9B,OAAK5P,KAAKkK,0BAAkD,SAAtBlK,KAAKgK,aAGhChK,KAAKkQ,cAAc7J,EAAQuJ,GAF3B5P,KAAKmQ,gBAab3C,EAAAtN,UAAAkQ,iCAAP,SAAwC3G,GAAxC,IAAAhB,EAAAzI,KACI,YADoC,IAAAyJ,IAAAA,EAAA,MAC7BzJ,KAAKqQ,wBAAwB5N,MAAK,SAAA6N,GACrC,OAAO7H,EAAK8H,SAAS9G,OAWtB+D,EAAAtN,UAAAsQ,8BAAP,SAAqC/G,GAArC,IAAAhB,EAAAzI,KAII,YAJiC,IAAAyJ,IAAAA,EAAA,MAC5BA,IACDA,EAAU,CAAEwE,MAAO,KAEhBjO,KAAKoQ,iCAAiC3G,GAAShH,MAAK,SAAAQ,GACvD,SAAKwF,EAAK0G,oBAAsB1G,EAAKgI,yBACP,SAAtBhI,EAAKuB,aACLvB,EAAKiI,eAELjI,EAAKkI,oBAEF,OAOTnD,EAAAtN,UAAAqO,MAAV,eAAgB,IAAAqC,EAAA,GAAAC,EAAA,EAAAA,EAAAnQ,UAAAC,OAAAkQ,IAAAD,EAAAC,GAAAnQ,UAAAmQ,GACR7Q,KAAKiK,sBACLjK,KAAK+N,OAAOQ,MAAM7L,MAAM1C,KAAK+N,OAAQ6C,IAInCpD,EAAAtN,UAAA4Q,iCAAV,SAA2CC,GACvC,IAAMC,EAAmB,GACnBC,EAAajR,KAAKkR,oBAAoBH,GACtCI,EAAcnR,KAAKoR,yBAAyBL,GAelD,OAbKE,GACDD,EAAO/M,KACH,qEAIHkN,GACDH,EAAO/M,KACH,yHAKD+M,GAGDxD,EAAAtN,UAAAgR,oBAAV,SAA8BH,GAC1B,IAAKA,EACD,OAAO,EAGX,IAAMM,EAAQN,EAAIO,cAElB,OAA0B,IAAtBtR,KAAKwK,kBAKJ6G,EAAMhK,MAAM,kCACTgK,EAAMhK,MAAM,iCACM,eAAtBrH,KAAKwK,eAKF6G,EAAME,WAAW,cAGlB/D,EAAAtN,UAAAsR,mCAAV,SAA6CT,EAAyBU,GAClE,IAAKV,EACD,MAAM,IAAIzJ,MAAM,IAAImK,EAAW,wBAEnC,IAAKzR,KAAKkR,oBAAoBH,GAC1B,MAAM,IAAIzJ,MAAM,IAAImK,EAAW,kIAI7BjE,EAAAtN,UAAAkR,yBAAV,SAAmCL,GAC/B,OAAK/Q,KAAKyK,qCAGLsG,GAGEA,EAAIO,cAAcC,WAAWvR,KAAK0J,OAAO4H,iBAG1C9D,EAAAtN,UAAA4O,kBAAV,WAAA,IAAArG,EAAAzI,KAC0B,oBAAX2H,SAKP3H,KAAKmP,mBAAqBnP,KAAKyQ,yBAC/BzQ,KAAK0R,wBACL1R,KAAK2R,oBACL3R,KAAKsP,yBAGLtP,KAAK4R,2BACL5R,KAAK4R,0BAA0BC,cAEnC7R,KAAK4R,0BAA4B5R,KAAK0O,OAAOa,KAAKC,EAAAA,QAAO,SAAAnN,GAAK,MAAW,mBAAXA,EAAEiG,SAA4BmH,WAAU,SAAAxM,GAClGwF,EAAKiJ,wBACLjJ,EAAKkJ,oBACLlJ,EAAK6G,4BAhBLtP,KAAKuO,MAAM,0CAoBTf,EAAAtN,UAAAoP,sBAAV,WACQtP,KAAKyQ,uBACLzQ,KAAK8R,wBAIL9R,KAAKmP,mBACLnP,KAAK+R,qBAIHvE,EAAAtN,UAAA4R,sBAAV,WAAA,IAAArJ,EAAAzI,KAEUgS,EAAahS,KAAKiS,2BAClBC,EAAWlS,KAAKmS,yBAChBC,EAAUpS,KAAKqS,YAAYH,EAAUF,GAE3ChS,KAAKyN,OAAO6E,mBAAkB,WAC1B7J,EAAK8J,+BAAiCC,EAAAA,GAClC,IAAI5J,EAAe,gBAAiB,iBAEnC2G,KAAKkD,EAAAA,MAAML,IACX3C,WAAU,SAAApN,GACPoG,EAAKgF,OAAOiF,KAAI,WACZjK,EAAKyF,cAAc9L,KAAKC,aAMlCmL,EAAAtN,UAAA6R,kBAAV,WAAA,IAAAtJ,EAAAzI,KAEUgS,EAAahS,KAAK2S,uBAClBT,EAAWlS,KAAK4S,qBAChBR,EAAUpS,KAAKqS,YAAYH,EAAUF,GAE3ChS,KAAKyN,OAAO6E,mBAAkB,WAC1B7J,EAAKoK,2BAA6BL,EAAAA,GAC9B,IAAI5J,EAAe,gBAAiB,aAEnC2G,KAAKkD,EAAAA,MAAML,IACX3C,WAAU,SAAApN,GACPoG,EAAKgF,OAAOiF,KAAI,WACZjK,EAAKyF,cAAc9L,KAAKC,aAMlCmL,EAAAtN,UAAAwR,sBAAV,WACQ1R,KAAKuS,gCACLvS,KAAKuS,+BAA+BV,eAIlCrE,EAAAtN,UAAAyR,kBAAV,WACQ3R,KAAK6S,4BACL7S,KAAK6S,2BAA2BhB,eAI9BrE,EAAAtN,UAAAmS,YAAV,SAAsBH,EAAkBF,GACpC,IAAMc,EAAMC,KAAKD,MACXE,GAAShB,EAAaE,GAAYlS,KAAK6K,eAAiBiI,EAAMZ,GACpE,OAAOe,KAAKC,IAAI,EAAGF,IAehBxF,EAAAtN,UAAA0O,WAAP,SAAkBjB,GACd3N,KAAKmT,SAAWxF,EAChB3N,KAAKiP,iBAYFzB,EAAAtN,UAAAmQ,sBAAP,SAA6B+C,GAA7B,IAAA3K,EAAAzI,KACI,YADyB,IAAAoT,IAAAA,EAAA,MAClB,IAAItR,SAAQ,SAACC,EAASC,GACpBoR,KACDA,EAAU3K,EAAKiB,QAAU,IACZ2J,SAAS,OAClBD,GAAW,KAEfA,GAAW,oCAGV3K,EAAKyI,oBAAoBkC,GAK9B3K,EAAKiF,KAAK5I,IAAsBsO,GAAS3D,WACrC,SAAAa,GACI,IAAK7H,EAAK6K,0BAA0BhD,GAKhC,OAJA7H,EAAKyF,cAAc9L,KACf,IAAIyG,EAAgB,sCAAuC,YAE/D7G,EAAO,uCAIXyG,EAAKU,SAAWmH,EAAIiD,uBACpB9K,EAAKkB,UAAY2G,EAAIkD,sBAAwB/K,EAAKkB,UAClDlB,EAAK4F,oBAAsBiC,EAAImD,sBAC/BhL,EAAKiB,OAAS4G,EAAI5G,OAClBjB,EAAKoB,cAAgByG,EAAIoD,eACzBjL,EAAKsB,iBAAmBuG,EAAIqD,mBAAqBlL,EAAKsB,iBACtDtB,EAAKmL,QAAUtD,EAAIuD,SACnBpL,EAAKuC,sBAAwBsF,EAAIwD,sBAAwBrL,EAAKuC,sBAE9DvC,EAAKuF,yBAA0B,EAC/BvF,EAAK2F,+BAA+BhM,KAAKkO,GAErC7H,EAAKqC,sBACLrC,EAAKyG,sCAGTzG,EAAKsL,WACAtR,MAAK,SAAAiI,GACF,IAKMsJ,EAAQ,IAAIzL,EACd,4BANmB,CACnB0L,kBAAmB3D,EACnB5F,KAAMA,IAOVjC,EAAKyF,cAAc9L,KAAK4R,GACxBjS,EAAQiS,MAGX/D,OAAM,SAAAiE,GACHzL,EAAKyF,cAAc9L,KACf,IAAIyG,EAAgB,gCAAiCqL,IAEzDlS,EAAOkS,SAInB,SAAAA,GACIzL,EAAKsF,OAAOvJ,MAAM,mCAAoC0P,GACtDzL,EAAKyF,cAAc9L,KACf,IAAIyG,EAAgB,gCAAiCqL,IAEzDlS,EAAOkS,MA1DXlS,EAAO,2IAgETwL,EAAAtN,UAAA6T,SAAV,WAAA,IAAAtL,EAAAzI,KACI,OAAO,IAAI8B,SAAgB,SAACC,EAASC,GAC7ByG,EAAKmL,QACLnL,EAAKiF,KAAK5I,IAAI2D,EAAKmL,SAASnE,WACxB,SAAA/E,GACIjC,EAAKiC,KAAOA,EACZjC,EAAKyF,cAAc9L,KACf,IAAImG,EAAkB,8BAE1BxG,EAAQ2I,MAEZ,SAAAwJ,GACIzL,EAAKsF,OAAOvJ,MAAM,qBAAsB0P,GACxCzL,EAAKyF,cAAc9L,KACf,IAAIyG,EAAgB,kBAAmBqL,IAE3ClS,EAAOkS,MAIfnS,EAAQ,UAKVyL,EAAAtN,UAAAoT,0BAAV,SAAoChD,GAChC,IAAIU,EAEJ,OAAKhR,KAAKqL,iBAAmBiF,EAAI5G,SAAW1J,KAAK0J,QASjDsH,EAAShR,KAAK8Q,iCAAiCR,EAAIiD,yBACxC5S,OAAS,GAChBX,KAAK+N,OAAOvJ,MACR,gEACAwM,IAEG,IAGXA,EAAShR,KAAK8Q,iCAAiCR,EAAIkD,uBACxC7S,OAAS,GAChBX,KAAK+N,OAAOvJ,MACR,8DACAwM,IAEG,KAGXA,EAAShR,KAAK8Q,iCAAiCR,EAAIoD,iBACxC/S,OAAS,GAChBX,KAAK+N,OAAOvJ,MACR,wDACAwM,IAIRA,EAAShR,KAAK8Q,iCAAiCR,EAAIqD,oBACxChT,OAAS,GAChBX,KAAK+N,OAAOvJ,MACR,2DACAwM,IAEG,IAGXA,EAAShR,KAAK8Q,iCAAiCR,EAAIuD,WACxClT,OAAS,GAChBX,KAAK+N,OAAOvJ,MAAM,kDAAmDwM,IAC9D,IAGPhR,KAAK8K,uBAAyBwF,EAAIwD,sBAClC9T,KAAK+N,OAAOoG,KACR,2GAKD,KAxDHnU,KAAK+N,OAAOvJ,MACR,uCACA,aAAexE,KAAK0J,OACpB,YAAc4G,EAAI5G,SAEf,IAoER8D,EAAAtN,UAAAkU,8CAAP,SACIC,EACAC,EACAC,GAHJ,IAAA9L,EAAAzI,KAKI,YAFA,IAAAuU,IAAAA,EAAA,IAA2BC,EAAAA,aAEpBxU,KAAKyU,4BAA4BJ,EAAUC,EAAUC,GAAS9R,MACjE,WAAM,OAAAgG,EAAKiM,sBAUZlH,EAAAtN,UAAAwU,gBAAP,WAAA,IAAAjM,EAAAzI,KACI,IAAKA,KAAKyQ,sBACN,MAAM,IAAInJ,MAAM,kDAEpB,IAAKtH,KAAKkR,oBAAoBlR,KAAK+J,kBAC/B,MAAM,IAAIzC,MAAM,gJAGpB,OAAO,IAAIxF,SAAQ,SAACC,EAASC,GACzB,IAAMuS,GAAU,IAAIC,EAAAA,aAActP,IAC9B,gBACA,UAAYuD,EAAKkM,kBAGrBlM,EAAKiF,KAAK5I,IAAc2D,EAAKsB,iBAAkB,CAAEwK,QAAOA,IAAI9E,WACxD,SAAAjH,GACIC,EAAK8F,MAAM,oBAAqB/F,GAEhC,IAAMoM,EAAiBnM,EAAKoM,qBAAuB,GAEnD,GAAKpM,EAAK0C,mBAEF1C,EAAKc,MACHqL,EAAoB,KAAKpM,EAAKsM,MAAQF,EAAoB,IAYpEpM,EAAOhJ,OAAOqM,OAAO,GAAI+I,EAAgBpM,GAEzCC,EAAK0K,SAASlO,QAAQ,sBAAuB8P,KAAKC,UAAUxM,IAC5DC,EAAKyF,cAAc9L,KAAK,IAAImG,EAAkB,wBAC9CxG,EAAQyG,OAnBR,CAUQxG,EAJI,uMAehB,SAAAkS,GACIzL,EAAKsF,OAAOvJ,MAAM,0BAA2B0P,GAC7CzL,EAAKyF,cAAc9L,KACf,IAAIyG,EAAgB,0BAA2BqL,IAEnDlS,EAAOkS,UAYhB1G,EAAAtN,UAAAuU,4BAAP,SACIJ,EACAC,EACAC,GAHJ,IAAA9L,EAAAzI,KAQI,YALA,IAAAuU,IAAAA,EAAA,IAA2BC,EAAAA,aAG3BxU,KAAKwR,mCAAmCxR,KAAK6J,cAAe,iBAErD,IAAI/H,SAAQ,SAACC,EAASC,WAOrBqE,EAAS,IAAI4O,EAAAA,WAAW,CAAExI,QAAS,IAAIX,IACtC5G,IAAI,aAAc,YAClBA,IAAI,QAASuD,EAAKW,OAClBlE,IAAI,WAAYmP,GAChBnP,IAAI,WAAYoP,GAErB,GAAI7L,EAAK8C,iBAAkB,CACvB,IAAM2J,EAASjP,KAAQwC,EAAKO,SAAQ,IAAIP,EAAK8B,mBAC7CgK,EAAUA,EAAQrP,IACd,gBACA,SAAWgQ,GAWnB,GARKzM,EAAK8C,mBACNlF,EAASA,EAAOnB,IAAI,YAAauD,EAAKO,YAGrCP,EAAK8C,kBAAoB9C,EAAK8B,oBAC/BlE,EAASA,EAAOnB,IAAI,gBAAiBuD,EAAK8B,oBAG1C9B,EAAKkC,sBACL,IAAkB,IAAAwK,EAAAjR,EAAA1E,OAAO4V,oBAAoB3M,EAAKkC,oBAAkB0K,EAAAF,EAAA/S,QAAAiT,EAAA7S,KAAA6S,EAAAF,EAAA/S,OAAE,CAAjE,IAAM7B,EAAG8U,EAAAnT,MACVmE,EAASA,EAAOnB,IAAI3E,EAAKkI,EAAKkC,kBAAkBpK,sGAIxDgU,EAAUA,EAAQrP,IACd,eACA,qCAGJuD,EAAKiF,KACA4H,KAAoB7M,EAAKoB,cAAexD,EAAQ,CAAEkO,QAAOA,IACzD9E,WACG,SAAA8F,GACI9M,EAAK8F,MAAM,gBAAiBgH,GAC5B9M,EAAK+M,yBACDD,EAAcE,aACdF,EAAcG,cACdH,EAAcI,WACdJ,EAAcnM,MACdX,EAAKmN,kCAAkCL,IAG3C9M,EAAKyF,cAAc9L,KAAK,IAAImG,EAAkB,mBAC9CxG,EAAQwT,MAEZ,SAAArB,GACIzL,EAAKsF,OAAOvJ,MAAM,iCAAkC0P,GACpDzL,EAAKyF,cAAc9L,KAAK,IAAIyG,EAAgB,cAAeqL,IAC3DlS,EAAOkS,UAapB1G,EAAAtN,UAAAiQ,aAAP,WAAA,IAAA1H,EAAAzI,KAGI,OAFAA,KAAKwR,mCAAmCxR,KAAK6J,cAAe,iBAErD,IAAI/H,SAAQ,SAACC,EAASC,WACrBqE,GAAS,IAAI4O,EAAAA,YACZ/P,IAAI,aAAc,iBAClBA,IAAI,QAASuD,EAAKW,OAClBlE,IAAI,gBAAiBuD,EAAK0K,SAAStO,QAAQ,kBAE5C0P,GAAU,IAAIC,EAAAA,aAActP,IAC5B,eACA,qCAGJ,GAAIuD,EAAK8C,iBAAkB,CACvB,IAAM2J,EAASjP,KAAQwC,EAAKO,SAAQ,IAAIP,EAAK8B,mBAC7CgK,EAAUA,EAAQrP,IACd,gBACA,SAAWgQ,GAWnB,GARKzM,EAAK8C,mBACNlF,EAASA,EAAOnB,IAAI,YAAauD,EAAKO,YAGrCP,EAAK8C,kBAAoB9C,EAAK8B,oBAC/BlE,EAASA,EAAOnB,IAAI,gBAAiBuD,EAAK8B,oBAG1C9B,EAAKkC,sBACL,IAAkB,IAAAwK,EAAAjR,EAAA1E,OAAO4V,oBAAoB3M,EAAKkC,oBAAkB0K,EAAAF,EAAA/S,QAAAiT,EAAA7S,KAAA6S,EAAAF,EAAA/S,OAAE,CAAjE,IAAM7B,EAAG8U,EAAAnT,MACVmE,EAASA,EAAOnB,IAAI3E,EAAKkI,EAAKkC,kBAAkBpK,sGAIxDkI,EAAKiF,KACA4H,KAAoB7M,EAAKoB,cAAexD,EAAQ,CAAEkO,QAAOA,IACzDhF,KAAKsG,EAAAA,WAAU,SAAAN,GACZ,OAAIA,EAAcO,SACPC,EAAAA,KAAKtN,EAAKuN,eAAeT,EAAcO,SAAUP,EAAcE,cAAc,IAC/ElG,KACGO,EAAAA,KAAI,SAAAvN,GAAU,OAAAkG,EAAKwN,aAAa1T,MAChCoD,EAAAA,KAAI,SAAA1C,GAAK,OAAAsS,MAGV/C,EAAAA,GAAG+C,OAGjB9F,WACG,SAAA8F,GACI9M,EAAK8F,MAAM,wBAAyBgH,GACpC9M,EAAK+M,yBACDD,EAAcE,aACdF,EAAcG,cACdH,EAAcI,WACdJ,EAAcnM,MACdX,EAAKmN,kCAAkCL,IAG3C9M,EAAKyF,cAAc9L,KAAK,IAAImG,EAAkB,mBAC9CE,EAAKyF,cAAc9L,KAAK,IAAImG,EAAkB,oBAC9CxG,EAAQwT,MAEZ,SAAArB,GACIzL,EAAKsF,OAAOvJ,MAAM,yBAA0B0P,GAC5CzL,EAAKyF,cAAc9L,KACf,IAAIyG,EAAgB,sBAAuBqL,IAE/ClS,EAAOkS,UAMjB1G,EAAAtN,UAAAgW,iCAAV,WACQlW,KAAKmW,wCACLxO,OAAOyO,oBACH,UACApW,KAAKmW,uCAETnW,KAAKmW,sCAAwC,OAI3C3I,EAAAtN,UAAAmW,gCAAV,WAAA,IAAA5N,EAAAzI,KACIA,KAAKkW,mCAELlW,KAAKmW,sCAAwC,SAAC9T,GAC1C,IAAMiU,EAAU7N,EAAK8N,2BAA2BlU,GAEhDoG,EAAK8H,SAAS,CACV9I,mBAAoB6O,EACpB7R,4BAA4B,EAC5B+R,kBAAmB/N,EAAKyB,0BAA4BzB,EAAKQ,cAC1DgH,OAAM,SAAAiE,GAAO,OAAAzL,EAAK8F,MAAM,wCAAyC2F,OAGxEvM,OAAO8O,iBACH,UACAzW,KAAKmW,wCASN3I,EAAAtN,UAAAgQ,cAAP,SAAqB7J,EAAqBuJ,GAA1C,IAAAnH,EAAAzI,UAAqB,IAAAqG,IAAAA,EAAA,SAAqB,IAAAuJ,IAAAA,GAAA,GACtC,IAAM8G,EAAiB1W,KAAK6U,qBAAuB,GAMnD,GAJI7U,KAAKoL,gCAAkCpL,KAAKmP,oBAC5C9I,EAAsB,cAAIrG,KAAK2W,eAG9B3W,KAAKkR,oBAAoBlR,KAAKmJ,UAC/B,MAAM,IAAI7B,MAAM,yIAGpB,GAAwB,oBAAbsP,SACP,MAAM,IAAItP,MAAM,oDAGpB,IAAMuP,EAAiBD,SAASE,eAC5B9W,KAAK4K,yBAGLiM,GACAD,SAAShU,KAAKmU,YAAYF,GAG9B7W,KAAKgX,qBAAuBN,EAAY,IAExC,IAAMO,EAASL,SAASM,cAAc,UACtCD,EAAOE,GAAKnX,KAAK4K,wBAEjB5K,KAAKqW,kCAEL,IAAMpN,EAAcjJ,KAAKkK,0BAA4BlK,KAAKiJ,YAC1DjJ,KAAKoX,eAAe,KAAM,KAAMnO,EAAa2G,EAAUvJ,GAAQ5D,MAAK,SAAAsO,GAChEkG,EAAOI,aAAa,MAAOtG,GAEtBtI,EAAK2B,0BACN6M,EAAOK,MAAe,QAAI,QAE9BV,SAAShU,KAAK2U,YAAYN,MAG9B,IAAMjG,EAAShR,KAAK0O,OAAOa,KACvBC,EAAAA,QAAO,SAAAnN,GAAK,OAAAA,aAAawG,KACzB2O,EAAAA,SAEEC,EAAUzX,KAAK0O,OAAOa,KACxBC,EAAAA,QAAO,SAAAnN,GAAK,MAAW,mBAAXA,EAAEiG,QACdkP,EAAAA,SAEEpF,EAAUI,EAAAA,GACZ,IAAI3J,EAAgB,yBAA0B,OAChD0G,KAAKkD,EAAAA,MAAMzS,KAAKsK,uBAElB,OAAOoN,EAAAA,KAAK,CAAC1G,EAAQyG,EAASrF,IACzB7C,KACG5J,EAAAA,KAAI,SAAAtD,GACA,GAAIA,aAAawG,EAOb,KANe,2BAAXxG,EAAEiG,KACFG,EAAKyF,cAAc9L,KAAKC,IAExBA,EAAI,IAAIwG,EAAgB,uBAAwBxG,GAChDoG,EAAKyF,cAAc9L,KAAKC,IAEtBA,EAKV,MAJsB,mBAAXA,EAAEiG,OACTjG,EAAI,IAAIkG,EAAkB,sBAC1BE,EAAKyF,cAAc9L,KAAKC,IAErBA,MAGdsV,aAQFnK,EAAAtN,UAAA0X,wBAAP,SAA+BnO,GAC3B,OAAOzJ,KAAK6X,qBAAqBpO,IAG9B+D,EAAAtN,UAAA2X,qBAAP,SAA4BpO,GAA5B,IAAAhB,EAAAzI,KAEI,OADAyJ,EAAUA,GAAW,GACdzJ,KAAKoX,eAAe,KAAM,KAAMpX,KAAKkK,0BAA0B,EAAO,CACzE4N,QAAS,UACVrV,MAAK,SAAAsO,GACJ,OAAO,IAAIjP,SAAQ,SAACC,EAASC,GAIzB,IAEI+V,EADAC,EAAYrQ,OAAOsQ,KAAKlH,EAAK,SAAUtI,EAAKyP,uBAAuBzO,IAQlEuO,EAGDD,EAA2BpQ,OAAOwQ,aATV,WACnBH,IAAaA,EAAUI,SACxBC,IACArW,EAAO,IAAI6G,EAAgB,eAAgB,QANf,KAUhC7G,EAAO,IAAI6G,EAAgB,gBAAiB,KAKhD,IAAMwP,EAAU,WACZ1Q,OAAO2Q,cAAcP,GACrBpQ,OAAOyO,oBAAoB,UAAWmC,GACpB,OAAdP,GACAA,EAAUQ,QAEdR,EAAY,MAGVO,EAAW,SAAClW,GACd,IAAMiU,EAAU7N,EAAK8N,2BAA2BlU,GAE5CiU,GAAuB,OAAZA,EACX7N,EAAK8H,SAAS,CACV9I,mBAAoB6O,EACpB7R,4BAA4B,EAC5B+R,kBAAmB/N,EAAKyB,2BACzBzH,MAAK,WACJ4V,IACAtW,OACD,SAAAmS,GACCmE,IACArW,EAAOkS,MAGXhN,QAAQuR,IAAI,uBAKpB9Q,OAAO8O,iBAAiB,UAAW8B,UAKrC/K,EAAAtN,UAAAgY,uBAAV,SAAiCzO,GAG7B,IAAMiP,EAASjP,EAAQiP,QAAU,IAC3BC,EAAQlP,EAAQkP,OAAS,IACzBC,EAAOjR,OAAOkR,YAAelR,OAAOmR,WAAaH,GAAS,EAEhE,MAAO,gCAAgCA,EAAK,WAAWD,EAAM,SADjD/Q,OAAOoR,WAAcpR,OAAOqR,YAAcN,GAAU,GACQ,SAASE,GAG3EpL,EAAAtN,UAAAqW,2BAAV,SAAqClU,GACjC,IAAI4W,EAAiB,IAMrB,GAJIjZ,KAAKmK,6BACL8O,GAAkBjZ,KAAKmK,4BAGtB9H,GAAMA,EAAEsC,MAA0B,iBAAXtC,EAAEsC,KAA9B,CAIA,IAAMuU,EAA0B7W,EAAEsC,KAElC,GAAKuU,EAAgB3H,WAAW0H,GAIhC,MAAO,IAAMC,EAAgBpS,OAAOmS,EAAetY,UAG7C6M,EAAAtN,UAAAiZ,uBAAV,WACI,QAAKnZ,KAAK8K,uBAGL9K,KAAKgL,sBAMWhL,KAAKoZ,kBAOF,oBAAbxC,UALP1P,QAAQiN,KACJ,oEAEG,IAVPjN,QAAQiN,KACJ,4EAEG,KAgBL3G,EAAAtN,UAAAmZ,+BAAV,WAAA,IAAA5Q,EAAAzI,KACIA,KAAKsZ,kCAELtZ,KAAKuZ,0BAA4B,SAAClX,GAC9B,IAAMmX,EAASnX,EAAEmX,OAAOlI,cAClB5H,EAASjB,EAAKiB,OAAO4H,cAI3B,GAFA7I,EAAK8F,MAAM,6BAEN7E,EAAO6H,WAAWiI,GAAvB,CAaA,OAAQnX,EAAEsC,MACN,IAAK,YACD8D,EAAKgR,yBACL,MACJ,IAAK,UACDhR,EAAKgF,OAAOiF,KAAI,WACZjK,EAAKiR,yBAET,MACJ,IAAK,QACDjR,EAAKgF,OAAOiF,KAAI,WACZjK,EAAKkR,wBAKjBlR,EAAK8F,MAAM,sCAAuClM,QA5B9CoG,EAAK8F,MACD,4BACA,eACAiL,EACA,WACA9P,IA2BZ1J,KAAKyN,OAAO6E,mBAAkB,WAC1B3K,OAAO8O,iBAAiB,UAAWhO,EAAK8Q,+BAItC/L,EAAAtN,UAAAuZ,uBAAV,WACIzZ,KAAKuO,MAAM,gBAAiB,sBAGtBf,EAAAtN,UAAAwZ,oBAAV,WAAA,IAAAjR,EAAAzI,KAEIA,KAAKkO,cAAc9L,KAAK,IAAIwG,EAAe,oBAC3C5I,KAAK4Z,wBACD5Z,KAAKkK,0BACLlK,KAAKkQ,gBAAgBD,OAAM,SAAAhN,GACvB,OAAAwF,EAAK8F,MAAM,kDAEfvO,KAAK6Z,2CAEL7Z,KAAKkO,cAAc9L,KAAK,IAAIwG,EAAe,uBAC3C5I,KAAK8Z,QAAO,KAIVtM,EAAAtN,UAAA2Z,uCAAV,WAAA,IAAApR,EAAAzI,KACIA,KAAK0O,OACAa,KACGC,EAAAA,QACI,SAACnN,GACG,MAAW,uBAAXA,EAAEiG,MACS,2BAAXjG,EAAEiG,MACS,yBAAXjG,EAAEiG,QAEVkP,EAAAA,SAEH/H,WAAU,SAAApN,GACQ,uBAAXA,EAAEiG,OACFG,EAAK8F,MAAM,qDACX9F,EAAKyF,cAAc9L,KAAK,IAAIwG,EAAe,uBAC3CH,EAAKqR,QAAO,QAKlBtM,EAAAtN,UAAAyZ,mBAAV,WACI3Z,KAAK4Z,wBACL5Z,KAAKkO,cAAc9L,KAAK,IAAIwG,EAAe,mBAGrC4E,EAAAtN,UAAAoZ,gCAAV,WACQtZ,KAAKuZ,4BACL5R,OAAOyO,oBAAoB,UAAWpW,KAAKuZ,2BAC3CvZ,KAAKuZ,0BAA4B,OAI/B/L,EAAAtN,UAAAkP,iBAAV,WACI,GAAKpP,KAAKmZ,yBAAV,CAIA,IAAMtC,EAAiBD,SAASE,eAAe9W,KAAKiL,wBAChD4L,GACAD,SAAShU,KAAKmU,YAAYF,GAG9B,IAAMI,EAASL,SAASM,cAAc,UACtCD,EAAOE,GAAKnX,KAAKiL,uBAEjBjL,KAAKqZ,iCAEL,IAAMtI,EAAM/Q,KAAKgL,sBACjBiM,EAAOI,aAAa,MAAOtG,GAC3BkG,EAAOK,MAAMQ,QAAU,OACvBlB,SAAShU,KAAK2U,YAAYN,GAE1BjX,KAAK+Z,2BAGCvM,EAAAtN,UAAA6Z,uBAAV,WAAA,IAAAtR,EAAAzI,KACIA,KAAK4Z,wBACL5Z,KAAKyN,OAAO6E,mBAAkB,WAC1B7J,EAAKuR,kBAAoB7B,YACrB1P,EAAKwR,aAAaC,KAAKzR,GACvBA,EAAKsC,2BAKPyC,EAAAtN,UAAA0Z,sBAAV,WACQ5Z,KAAKga,oBACL1B,cAActY,KAAKga,mBACnBha,KAAKga,kBAAoB,OAIvBxM,EAAAtN,UAAA+Z,aAAV,WACI,IAAMhD,EAAcL,SAASE,eAAe9W,KAAKiL,wBAE5CgM,GACDjX,KAAK+N,OAAOoG,KACR,mCACAnU,KAAKiL,wBAIb,IAAMkP,EAAena,KAAKoZ,kBAErBe,GACDna,KAAK4Z,wBAGT,IAAMtD,EAAUtW,KAAKgJ,SAAW,IAAMmR,EACtClD,EAAOmD,cAAcC,YAAY/D,EAAStW,KAAK0J,SAGnC8D,EAAAtN,UAAAkX,eAAhB,SACInJ,EACAqM,EACA9D,EACA5G,EACAvJ,eAJA,IAAA4H,IAAAA,EAAA,SACA,IAAAqM,IAAAA,EAAA,SACA,IAAA9D,IAAAA,EAAA,SACA,IAAA5G,IAAAA,GAAA,QACA,IAAAvJ,IAAAA,EAAA,+HAYc,OAVRkU,EAAOva,KAKTiJ,EADAuN,GAGcxW,KAAKiJ,YAGT,CAAA,EAAMjJ,KAAKwa,6BAQzB,GARMC,EAAQC,EAAAvX,OAGV8K,EADAA,EACQwM,EAAQza,KAAK6N,OAAOvC,oBAAsB2C,EAE1CwM,GAGPza,KAAKwJ,qBAAuBxJ,KAAKuJ,KAClC,MAAM,IAAIjC,MACN,iEAIJtH,KAAK6N,OAAO7D,aACZhK,KAAKgK,aAAehK,KAAK6N,OAAO7D,aAE5BhK,KAAKuJ,MAAQvJ,KAAKwJ,mBAClBxJ,KAAKgK,aAAe,iBACbhK,KAAKuJ,OAASvJ,KAAKwJ,mBAC1BxJ,KAAKgK,aAAe,WAEpBhK,KAAKgK,aAAe,QAItB2Q,EAAiBJ,EAAKpR,SAAStB,QAAQ,MAAQ,EAAI,IAAM,IAE3DuB,EAAQmR,EAAKnR,MAEbpJ,KAAKuJ,OAASH,EAAM/B,MAAM,wBAC1B+B,EAAQ,UAAYA,GAGpB2H,EACAwJ,EAAKpR,SACLwR,EACA,iBACA1O,mBAAmBsO,EAAKvQ,cACxB,cACAiC,mBAAmBsO,EAAKvR,UACxB,UACAiD,mBAAmBgC,GACnB,iBACAhC,mBAAmBhD,GACnB,UACAgD,mBAAmB7C,GAEG,SAAtBpJ,KAAKgK,cAA4BhK,KAAKyL,YAAtC,CAAA,EAAA,GAC8B,CAAA,EAAMzL,KAAK4a,6CAAnChU,EAAAtC,EAAA5B,WAAA,EAAA,CAAwBgY,EAAAvX,OAA+C,IAAtE0X,EAASjU,EAAA,GAAEkU,EAAQlU,EAAA,GAC1B5G,KAAKmT,SAASlO,QAAQ,gBAAiB6V,GACvC/J,GAAO,mBAAqB8J,EAC5B9J,GAAO,+CAGPuJ,IACAvJ,GAAO,eAAiB9E,mBAAmBqO,IAG3CC,EAAKlR,WACL0H,GAAO,aAAe9E,mBAAmBsO,EAAKlR,WAG9CkR,EAAKhR,OACLwH,GAAO,UAAY9E,mBAAmBwO,IAGtC7K,IACAmB,GAAO,oBAGX,IAAkBoE,EAAAjR,EAAA1E,OAAOub,KAAK1U,IAAOgP,EAAAF,EAAA/S,QAAAiT,EAAA7S,KAAA6S,EAAAF,EAAA/S,OAA1B7B,EAAG8U,EAAAnT,MACV6O,GACI,IAAM9E,mBAAmB1L,GAAO,IAAM0L,mBAAmB5F,EAAO9F,qGAGxE,GAAIP,KAAK2K,sBACL,IAAkBqQ,EAAA9W,EAAA1E,OAAO4V,oBAAoBpV,KAAK2K,oBAAkBsQ,EAAAD,EAAA5Y,QAAA6Y,EAAAzY,KAAAyY,EAAAD,EAAA5Y,OAAzD7B,EAAG0a,EAAA/Y,MACV6O,GACI,IAAMxQ,EAAM,IAAM0L,mBAAmBjM,KAAK2K,kBAAkBpK,qGAIxE,MAAA,CAAA,EAAOwQ,WAIXvD,EAAAtN,UAAAgb,yBAAA,SACIC,EACA9U,GAFJ,IAAAoC,EAAAzI,KAII,QAHA,IAAAmb,IAAAA,EAAA,SACA,IAAA9U,IAAAA,EAAA,KAEIrG,KAAKsO,eAAT,CAMA,GAFAtO,KAAKsO,gBAAiB,GAEjBtO,KAAKkR,oBAAoBlR,KAAKmJ,UAC/B,MAAM,IAAI7B,MACN,yIAIR,IAAI8T,EAAoB,GACpBd,EAAoB,KAEF,iBAAXjU,EACPiU,EAAYjU,EACa,iBAAXA,IACd+U,EAAY/U,GAGhBrG,KAAKoX,eAAe+D,EAAiBb,EAAW,MAAM,EAAOc,GACxD3Y,KAAKzC,KAAK6N,OAAOnC,SACjBuE,OAAM,SAAAzL,GACH0C,QAAQ1C,MAAM,4BAA6BA,GAC3CiE,EAAK6F,gBAAiB,OAa3Bd,EAAAtN,UAAAyQ,iBAAP,SACIwK,EACA9U,GAFJ,IAAAoC,EAAAzI,UACI,IAAAmb,IAAAA,EAAA,SACA,IAAA9U,IAAAA,EAAA,IAEsB,KAAlBrG,KAAKmJ,SACLnJ,KAAKkb,yBAAyBC,EAAiB9U,GAE/CrG,KAAK0O,OACAa,KAAKC,EAAAA,QAAO,SAAAnN,GAAK,MAAW,8BAAXA,EAAEiG,SACnBmH,WAAU,SAAAxM,GAAK,OAAAwF,EAAKyS,yBAAyBC,EAAiB9U,OASpEmH,EAAAtN,UAAAmb,kBAAP,WACIrb,KAAKsO,gBAAiB,GAGhBd,EAAAtN,UAAAob,4BAAV,SAAsC7R,GAElC,GAAIA,EAAQ8R,gBAAiB,CACzB,IAAMC,EAAc,CAChBC,SAHKzb,KAGU6U,oBACf6G,QAJK1b,KAIS2W,aACdjQ,YALK1G,KAKa2U,iBAClB1G,MANKjO,KAMOiO,OAEhBxE,EAAQ8R,gBAAgBC,KAItBhO,EAAAtN,UAAAsV,yBAAV,SACI9O,EACAyJ,EACAwL,EACAC,EACAC,GALJ,IAAApT,EAAAzI,KAYI,GALAA,KAAKmT,SAASlO,QAAQ,eAAgByB,GAClCkV,GACA5b,KAAKmT,SAASlO,QAAQ,iBAAkB8P,KAAKC,UAAU4G,EAAclW,MAAM,OAE/E1F,KAAKmT,SAASlO,QAAQ,yBAA0B,GAAK8N,KAAKD,OACtD6I,EAAW,CACX,IAAMG,EAAoC,IAAZH,EAExBI,GADM,IAAIhJ,MACMiJ,UAAYF,EAClC9b,KAAKmT,SAASlO,QAAQ,aAAc,GAAK8W,GAGzC5L,GACAnQ,KAAKmT,SAASlO,QAAQ,gBAAiBkL,GAEvC0L,GACAA,EAAiBI,SAAQ,SAAC/Z,EAAgB3B,GACxCkI,EAAK0K,SAASlO,QAAQ1E,EAAK2B,OAS9BsL,EAAAtN,UAAAqQ,SAAP,SAAgB9G,GACZ,YADY,IAAAA,IAAAA,EAAA,MACqB,SAA7BzJ,KAAK6N,OAAO7D,aACLhK,KAAKkc,iBAAiBzS,GAAShH,MAAK,SAAAQ,GAAK,OAAA,KAGzCjD,KAAKmc,qBAAqB1S,IAMjC+D,EAAAtN,UAAA6H,iBAAR,SAAyBC,GACrB,OAAKA,GAAsC,IAAvBA,EAAYrH,QAIF,MAA1BqH,EAAYoU,OAAO,KACnBpU,EAAcA,EAAYlB,OAAO,IAG9B9G,KAAK8N,UAAU/F,iBAAiBC,IAP5B,IAYRwF,EAAAtN,UAAAgc,iBAAP,SAAwBzS,GAAxB,IAAAhB,EAAAzI,UAAwB,IAAAyJ,IAAAA,EAAA,OACpBA,EAAUA,GAAW,IAEOhC,mBACxBgC,EAAQhC,mBAAmB4U,UAAU,GACrC1U,OAAOC,SAAS0U,OAFpB,IAIMC,EAAQvc,KAAKwc,oBAAoB7U,OAAOC,SAAS0U,QAEjDG,EAAOF,EAAY,KACnBtO,EAAQsO,EAAa,MAE3B,IAAK9S,EAAQhF,2BAA4B,CACrC,IAAMmH,EAAOhE,SAASgE,KACjBrG,QAAQ,oBAAqB,IAC7BA,QAAQ,qBAAsB,IAC9BA,QAAQ,qBAAsB,IAC9BA,QAAQ,6BAA8B,IAE3CmX,QAAQC,aAAa,KAAMhV,OAAOiV,KAAMhR,GAGxC,IAAAhF,EAAAtC,EAAAtE,KAAA6c,WAAA5O,GAAA,GAAC6O,EAAAlW,EAAA,GAAcmW,EAAAnW,EAAA,GAGnB,GAFA5G,KAAKiO,MAAQ8O,EAETR,EAAa,MAAG,CAChBvc,KAAKuO,MAAM,yBACXvO,KAAKgd,iBAAiB,GAAIT,GAC1B,IAAMrI,EAAM,IAAIrL,EAAgB,aAAc,GAAI0T,GAElD,OADAvc,KAAKkO,cAAc9L,KAAK8R,GACjBpS,QAAQE,OAAOkS,GAG1B,IAAK4I,EACD,OAAOhb,QAAQC,UAInB,IADgB/B,KAAKid,cAAcH,GACrB,CACV,IAAMI,EAAQ,IAAIrU,EAAgB,yBAA0B,MAE5D,OADA7I,KAAKkO,cAAc9L,KAAK8a,GACjBpb,QAAQE,OAAOkb,GAG1B,OAAIT,EACO,IAAI3a,SAAQ,SAACC,EAASC,GACzByG,EAAK0U,iBAAiBV,EAAMhT,GAAShH,MAAK,SAAAF,GACtCR,OACDkO,OAAM,SAAAiE,GACLlS,EAAOkS,SAIRpS,QAAQC,WAQfyL,EAAAtN,UAAAsc,oBAAR,SAA4BxU,GACxB,OAAKA,GAAsC,IAAvBA,EAAYrH,QAKF,MAA1BqH,EAAYoU,OAAO,KACnBpU,EAAcA,EAAYlB,OAAO,IAG9B9G,KAAK8N,UAAU/F,iBAAiBC,IAR5BhI,KAAK8N,UAAUtG,yBActBgG,EAAAtN,UAAAid,iBAAR,SAAyBV,EAAchT,GACnC,IAAIpD,GAAS,IAAI4O,EAAAA,YACZ/P,IAAI,aAAc,sBAClBA,IAAI,OAAQuX,GACZvX,IAAI,eAAgBuE,EAAQ+M,mBAAqBxW,KAAKiJ,aAE3D,IAAKjJ,KAAKyL,YAAa,CACnB,IAAM2R,EAAepd,KAAKmT,SAAStO,QAAQ,iBAEtCuY,EAGD/W,EAASA,EAAOnB,IAAI,gBAAiBkY,GAFrClW,QAAQiN,KAAK,4CAMrB,OAAOnU,KAAKqd,qBAAqBhX,IAG7BmH,EAAAtN,UAAAmd,qBAAR,SAA6BhX,GAA7B,IAAAoC,EAAAzI,KAEIA,KAAKwR,mCAAmCxR,KAAK6J,cAAe,iBAC5D,IAAI0K,GAAU,IAAIC,EAAAA,aACbtP,IAAI,eAAgB,qCAEzB,GAAIlF,KAAKuL,iBAAkB,CACvB,IAAM2J,EAASjP,KAAQjG,KAAKgJ,SAAQ,IAAIhJ,KAAKuK,mBAC7CgK,EAAUA,EAAQrP,IACd,gBACA,SAAWgQ,GAWnB,OARKlV,KAAKuL,mBACNlF,EAASA,EAAOnB,IAAI,YAAalF,KAAKgJ,YAGrChJ,KAAKuL,kBAAoBvL,KAAKuK,oBAC/BlE,EAASA,EAAOnB,IAAI,gBAAiBlF,KAAKuK,oBAGvC,IAAIzI,SAAQ,SAACC,EAASC,WAEzB,GAAIyG,EAAKkC,sBACL,IAAgB,IAAAwK,EAAAjR,EAAA1E,OAAO4V,oBAAoB3M,EAAKkC,oBAAkB0K,EAAAF,EAAA/S,QAAAiT,EAAA7S,KAAA6S,EAAAF,EAAA/S,OAAE,CAA/D,IAAI7B,EAAG8U,EAAAnT,MACRmE,EAASA,EAAOnB,IAAI3E,EAAKkI,EAAKkC,kBAAkBpK,sGAIxDkI,EAAKiF,KAAK4H,KAAoB7M,EAAKoB,cAAexD,EAAQ,CAAEkO,QAAOA,IAAI9E,WACnE,SAAC8F,GACG9M,EAAK8F,MAAM,wBAAyBgH,GACpC9M,EAAK+M,yBACDD,EAAcE,aACdF,EAAcG,cACdH,EAAcI,WACdJ,EAAcnM,MACdX,EAAKmN,kCAAkCL,IAEvC9M,EAAKc,MAAQgM,EAAcO,SAC3BrN,EAAKuN,eAAeT,EAAcO,SAAUP,EAAcE,cACtDhT,MAAK,SAAAF,GACDkG,EAAKwN,aAAa1T,GAElBkG,EAAKyF,cAAc9L,KAAK,IAAImG,EAAkB,mBAC9CE,EAAKyF,cAAc9L,KAAK,IAAImG,EAAkB,oBAE9CxG,EAAQwT,MAEXtF,OAAM,SAAAnH,GACHL,EAAKyF,cAAc9L,KAAK,IAAIyG,EAAgB,yBAA0BC,IACtE5B,QAAQ1C,MAAM,2BACd0C,QAAQ1C,MAAMsE,GAEd9G,EAAO8G,OAGfL,EAAKyF,cAAc9L,KAAK,IAAImG,EAAkB,mBAC9CE,EAAKyF,cAAc9L,KAAK,IAAImG,EAAkB,oBAE9CxG,EAAQwT,OAGhB,SAACrB,GACGhN,QAAQ1C,MAAM,sBAAuB0P,GACrCzL,EAAKyF,cAAc9L,KAAK,IAAIyG,EAAgB,sBAAuBqL,IACnElS,EAAOkS,UAchB1G,EAAAtN,UAAAic,qBAAP,SAA4B1S,GAA5B,IAGQ8S,EAHR9T,EAAAzI,UAA4B,IAAAyJ,IAAAA,EAAA,MAMpB8S,GALJ9S,EAAUA,GAAW,IAIThC,mBACAzH,KAAK8N,UAAUtG,sBAAsBiC,EAAQhC,oBAE7CzH,KAAK8N,UAAUtG,wBAG3BxH,KAAKuO,MAAM,aAAcgO,GAEzB,IAAMtO,EAAQsO,EAAa,MAEvB3V,EAAAtC,EAAAtE,KAAA6c,WAAA5O,GAAA,GAAC6O,EAAAlW,EAAA,GAAcmW,EAAAnW,EAAA,GAGnB,GAFA5G,KAAKiO,MAAQ8O,EAETR,EAAa,MAAG,CAChBvc,KAAKuO,MAAM,yBACXvO,KAAKgd,iBAAiBvT,EAAS8S,GAC/B,IAAMrI,EAAM,IAAIrL,EAAgB,cAAe,GAAI0T,GAEnD,OADAvc,KAAKkO,cAAc9L,KAAK8R,GACjBpS,QAAQE,OAAOkS,GAG1B,IAAMxN,EAAc6V,EAAoB,aAClCb,EAAUa,EAAgB,SAC1BpC,EAAeoC,EAAqB,cACpCX,EAAgBW,EAAa,MAEnC,IAAKvc,KAAKwJ,qBAAuBxJ,KAAKuJ,KAClC,OAAOzH,QAAQE,OACX,6DAIR,GAAIhC,KAAKwJ,qBAAuB9C,EAC5B,OAAO5E,QAAQC,SAAQ,GAE3B,GAAI/B,KAAKwJ,qBAAuBC,EAAQ6T,0BAA4BrP,EAChE,OAAOnM,QAAQC,SAAQ,GAE3B,GAAI/B,KAAKuJ,OAASmS,EACd,OAAO5Z,QAAQC,SAAQ,GAW3B,IARI/B,KAAK8K,uBAAyBqP,GAC9Bna,KAAK+N,OAAOoG,KACR,mJAMJnU,KAAKwJ,qBAAuBC,EAAQ6T,2BACpBtd,KAAKid,cAAcH,GAErB,CACV,IAAMS,EAAQ,IAAI1U,EAAgB,yBAA0B,MAE5D,OADA7I,KAAKkO,cAAc9L,KAAKmb,GACjBzb,QAAQE,OAAOub,GAa9B,OATIvd,KAAKwJ,oBACLxJ,KAAKwV,yBACD9O,EACA,KACA6V,EAAkB,YAAKvc,KAAKwd,uCAC5B5B,GAIH5b,KAAKuJ,KAWHvJ,KAAKgW,eAAe0F,EAAShV,GAC/BjE,MAAK,SAAAF,GACF,OAAIkH,EAAQgU,kBACDhU,EACFgU,kBAAkB,CACf/W,YAAaA,EACb+U,SAAUlZ,EAAO0E,cACjByU,QAASnZ,EAAOmZ,QAChBzN,MAAOA,IAEVxL,MAAK,SAAAQ,GAAK,OAAAV,KAEZA,KAEVE,MAAK,SAAAF,GASF,OARAkG,EAAKwN,aAAa1T,GAClBkG,EAAKiV,kBAAkBvD,GACnB1R,EAAKmB,sBAAwBH,EAAQhF,6BACrCmD,SAASF,KAAO,IAEpBe,EAAKyF,cAAc9L,KAAK,IAAImG,EAAkB,mBAC9CE,EAAK6S,4BAA4B7R,GACjChB,EAAK6F,gBAAiB,GACf,KAEV2B,OAAM,SAAAnH,GAMH,OALAL,EAAKyF,cAAc9L,KACf,IAAIyG,EAAgB,yBAA0BC,IAElDL,EAAKsF,OAAOvJ,MAAM,2BAClBiE,EAAKsF,OAAOvJ,MAAMsE,GACXhH,QAAQE,OAAO8G,OAzC1B9I,KAAKkO,cAAc9L,KAAK,IAAImG,EAAkB,mBAC1CvI,KAAK4J,sBAAwBH,EAAQhF,6BACrCmD,SAASF,KAAO,IAGpB1H,KAAKsb,4BAA4B7R,GAC1B3H,QAAQC,SAAQ,KAuCvByL,EAAAtN,UAAA2c,WAAR,SAAmB5O,GACf,IAAIwM,EAAQxM,EACR8O,EAAY,GAEhB,GAAI9O,EAAO,CACP,IAAM0P,EAAM1P,EAAMpG,QAAQ7H,KAAK6N,OAAOvC,qBAClCqS,GAAO,IACPlD,EAAQxM,EAAMnH,OAAO,EAAG6W,GACxBZ,EAAY9O,EAAMnH,OAAO6W,EAAM3d,KAAK6N,OAAOvC,oBAAoB3K,SAGvE,MAAO,CAAC8Z,EAAOsC,IAGTvP,EAAAtN,UAAA+c,cAAV,SACIH,GAEA,IAAMc,EAAa5d,KAAKmT,SAAStO,QAAQ,SACzC,GAAI+Y,IAAed,EAAc,CAI7B,OADA5V,QAAQ1C,MADI,qDACOoZ,EAAYd,IACxB,EAEX,OAAO,GAGDtP,EAAAtN,UAAA+V,aAAV,SAAuByF,GACnB1b,KAAKmT,SAASlO,QAAQ,WAAYyW,EAAQA,SAC1C1b,KAAKmT,SAASlO,QAAQ,sBAAuByW,EAAQmC,mBACrD7d,KAAKmT,SAASlO,QAAQ,sBAAuB,GAAKyW,EAAQoC,kBAC1D9d,KAAKmT,SAASlO,QAAQ,qBAAsB,GAAK8N,KAAKD,QAGhDtF,EAAAtN,UAAAwd,kBAAV,SAA4BvD,GACxBna,KAAKmT,SAASlO,QAAQ,gBAAiBkV,IAGjC3M,EAAAtN,UAAAkZ,gBAAV,WACI,OAAOpZ,KAAKmT,SAAStO,QAAQ,kBAGvB2I,EAAAtN,UAAA8c,iBAAV,SAA2BvT,EAAuB8S,GAC1C9S,EAAQsU,cACRtU,EAAQsU,aAAaxB,GAErBvc,KAAK4J,sBAAwBH,EAAQhF,6BACrCmD,SAASF,KAAO,KAOjB8F,EAAAtN,UAAA8V,eAAP,SACI0F,EACAhV,EACAsX,GAHJ,IAAAvV,EAAAzI,UAGI,IAAAge,IAAAA,GAAA,GAEA,IAAMC,EAAavC,EAAQhW,MAAM,KAE3BwY,EAAa9Y,EADEpF,KAAKme,UAAUF,EAAW,KAEzC/I,EAASH,KAAKqJ,MAAMF,GAEpBG,EAAajZ,EADEpF,KAAKme,UAAUF,EAAW,KAEzCvH,EAAS3B,KAAKqJ,MAAMC,GACpBT,EAAa5d,KAAKmT,SAAStO,QAAQ,SAEzC,GAAIlF,MAAM2e,QAAQ5H,EAAO6H,MACrB,GAAI7H,EAAO6H,IAAIC,OAAM,SAAA5a,GAAK,OAAAA,IAAM6E,EAAKO,YAAW,CAC5C,IAAMkL,EAAM,mBAAqBwC,EAAO6H,IAAIxY,KAAK,KAEjD,OADA/F,KAAK+N,OAAOoG,KAAKD,GACVpS,QAAQE,OAAOkS,SAG1B,GAAIwC,EAAO6H,MAAQve,KAAKgJ,SAAU,CACxBkL,EAAM,mBAAqBwC,EAAO6H,IAExC,OADAve,KAAK+N,OAAOoG,KAAKD,GACVpS,QAAQE,OAAOkS,GAI9B,IAAKwC,EAAO5B,IAAK,CACPZ,EAAM,2BAEZ,OADAlU,KAAK+N,OAAOoG,KAAKD,GACVpS,QAAQE,OAAOkS,GAQ1B,GACIlU,KAAK8K,sBACL9K,KAAKgX,sBACLhX,KAAKgX,uBAAyBN,EAAY,IAC5C,CACQxC,EACF,8EACiBlU,KAAKgX,qBAAoB,mBAC1CN,EAAY,IAIhB,OADA1W,KAAK+N,OAAOoG,KAAKD,GACVpS,QAAQE,OAAOkS,GAG1B,IAAKwC,EAAO+H,IAAK,CACPvK,EAAM,2BAEZ,OADAlU,KAAK+N,OAAOoG,KAAKD,GACVpS,QAAQE,OAAOkS,GAG1B,IAAKlU,KAAKqL,iBAAmBqL,EAAOgI,MAAQ1e,KAAK0J,OAAQ,CAC/CwK,EAAM,iBAAmBwC,EAAOgI,IAEtC,OADA1e,KAAK+N,OAAOoG,KAAKD,GACVpS,QAAQE,OAAOkS,GAG1B,IAAK8J,GAAkBtH,EAAO+D,QAAUmD,EAAY,CAC1C1J,EAAM,gBAAkBwC,EAAO+D,MAErC,OADAza,KAAK+N,OAAOoG,KAAKD,GACVpS,QAAQE,OAAOkS,GAS1B,GAHIlU,KAAKH,eAAe,iBAAyC,SAAtBG,KAAKgK,eAC5ChK,KAAKkL,oBAAqB,IAGzBlL,KAAKkL,oBACNlL,KAAKwJ,qBACJkN,EAAgB,QACnB,CACQxC,EAAM,wBAEZ,OADAlU,KAAK+N,OAAOoG,KAAKD,GACVpS,QAAQE,OAAOkS,GAG1B,IAAMpB,EAAMC,KAAKD,MACX6L,EAA4B,IAAbjI,EAAO+H,IACtBG,EAA6B,IAAblI,EAAOmI,IACvBC,EAAiD,KAA9B9e,KAAK+e,gBAAkB,KAEhD,GACIJ,EAAeG,GAAmBhM,GAClC8L,EAAgBE,GAAmBhM,EACrC,CACQoB,EAAM,oBAOZ,OANAhN,QAAQ1C,MAAM0P,GACdhN,QAAQ1C,MAAM,CACVsO,IAAKA,EACL6L,aAAcA,EACdC,cAAeA,IAEZ9c,QAAQE,OAAOkS,GAG1B,IAAM8K,EAAqC,CACvCtY,YAAaA,EACbgV,QAASA,EACThR,KAAM1K,KAAK0K,KACXzD,cAAeyP,EACflQ,cAAe0O,EACf+J,SAAU,WAAM,OAAAxW,EAAKsL,aAGzB,OAAI/T,KAAKkL,mBACElL,KAAKkf,eAAeF,GAAkBvc,MAAK,SAAAQ,GAS9C,MAR8B,CAC1ByY,QAASA,EACTzU,cAAeyP,EACfmH,kBAAmBQ,EACnB7X,cAAe0O,EACfiK,kBAAmBjB,EACnBJ,iBAAkBc,MAMvB5e,KAAKof,YAAYJ,GACnBvc,MAAK,SAAA4c,GACF,IACK5W,EAAKyC,oBACNzC,EAAKe,qBACJ6V,EACH,CACE,IAAMnL,EAAM,gBAEZ,OADAzL,EAAKsF,OAAOoG,KAAKD,GACVpS,QAAQE,OAAOkS,GAG1B,OAAOzL,EAAKyW,eAAeF,GAAkBvc,MAAK,SAAAQ,GAC9C,IAAMqc,GAAsB7W,EAAKyC,mBAC3B3I,EAAwB,CAC1BmZ,QAASA,EACTzU,cAAeyP,EACfmH,kBAAmBQ,EACnB7X,cAAe0O,EACfiK,kBAAmBjB,EACnBJ,iBAAkBc,GAEtB,OAAIU,EACO7W,EAAK2W,YAAYJ,GAAkBvc,MAAK,SAAA4c,GAC3C,GAAI5W,EAAKe,qBAAuB6V,EAAa,CACzC,IAAMnL,EAAM,gBAEZ,OADAzL,EAAKsF,OAAOoG,KAAKD,GACVpS,QAAQE,OAAOkS,GAEtB,OAAO3R,KAIRA,SASpBiL,EAAAtN,UAAA2U,kBAAP,WACI,IAAM6B,EAAS1W,KAAKmT,SAAStO,QAAQ,uBACrC,OAAK6R,EAGE3B,KAAKqJ,MAAM1H,GAFP,MAQRlJ,EAAAtN,UAAAqf,iBAAP,WACI,IAAMC,EAASxf,KAAKmT,SAAStO,QAAQ,kBACrC,OAAK2a,EAGEzK,KAAKqJ,MAAMoB,GAFP,MAQRhS,EAAAtN,UAAAyW,WAAP,WACI,OAAO3W,KAAKmT,SACNnT,KAAKmT,SAAStO,QAAQ,YACtB,MAGA2I,EAAAtN,UAAAie,UAAV,SAAoBsB,GAChB,KAAOA,EAAW9e,OAAS,GAAM,GAC7B8e,GAAc,IAElB,OAAOA,GAMJjS,EAAAtN,UAAAyU,eAAP,WACI,OAAO3U,KAAKmT,SACNnT,KAAKmT,SAAStO,QAAQ,gBACtB,MAGH2I,EAAAtN,UAAAwf,gBAAP,WACI,OAAO1f,KAAKmT,SACNnT,KAAKmT,SAAStO,QAAQ,iBACtB,MAOH2I,EAAAtN,UAAA+R,yBAAP,WACI,OAAKjS,KAAKmT,SAAStO,QAAQ,cAGpB8a,SAAS3f,KAAKmT,SAAStO,QAAQ,cAAe,IAF1C,MAKL2I,EAAAtN,UAAAiS,uBAAV,WACI,OAAOwN,SAAS3f,KAAKmT,SAAStO,QAAQ,0BAA2B,KAG3D2I,EAAAtN,UAAA0S,mBAAV,WACI,OAAO+M,SAAS3f,KAAKmT,SAAStO,QAAQ,sBAAuB,KAO1D2I,EAAAtN,UAAAyS,qBAAP,WACI,OAAK3S,KAAKmT,SAAStO,QAAQ,uBAIpB8a,SAAS3f,KAAKmT,SAAStO,QAAQ,uBAAwB,IAHnD,MASR2I,EAAAtN,UAAAuQ,oBAAP,WACI,GAAIzQ,KAAK2U,iBAAkB,CACvB,IAAMoH,EAAY/b,KAAKmT,SAAStO,QAAQ,cAClCiO,EAAM,IAAIC,KAChB,QAAIgJ,GAAa4D,SAAS5D,EAAW,IAAMjJ,EAAIkJ,WAOnD,OAAO,GAMJxO,EAAAtN,UAAAiP,gBAAP,WACI,GAAInP,KAAK2W,aAAc,CACnB,IAAMoF,EAAY/b,KAAKmT,SAAStO,QAAQ,uBAClCiO,EAAM,IAAIC,KAChB,QAAIgJ,GAAa4D,SAAS5D,EAAW,IAAMjJ,EAAIkJ,WAOnD,OAAO,GAMJxO,EAAAtN,UAAA0f,+BAAP,SAAsCC,GACpC,OAAO7f,KAAKmT,UAAYnT,KAAK6N,OAAO/D,uBAC5B9J,KAAK6N,OAAO/D,sBAAsBjC,QAAQgY,IAAsB,GAClB,OAA7C7f,KAAKmT,SAAStO,QAAQgb,GACvB9K,KAAKqJ,MAAMpe,KAAKmT,SAAStO,QAAQgb,IAAsB,MAO1DrS,EAAAtN,UAAA4f,oBAAP,WACI,MAAO,UAAY9f,KAAK2U,kBASrBnH,EAAAtN,UAAA4Z,OAAP,SAAciG,GAAd,IAAAtX,EAAAzI,UAAc,IAAA+f,IAAAA,GAAA,GACV,IAAMjK,EAAW9V,KAAK2W,aAmBtB,GAlBA3W,KAAKmT,SAASpO,WAAW,gBACzB/E,KAAKmT,SAASpO,WAAW,YACzB/E,KAAKmT,SAASpO,WAAW,iBACzB/E,KAAKmT,SAASpO,WAAW,SACzB/E,KAAKmT,SAASpO,WAAW,cACzB/E,KAAKmT,SAASpO,WAAW,uBACzB/E,KAAKmT,SAASpO,WAAW,uBACzB/E,KAAKmT,SAASpO,WAAW,sBACzB/E,KAAKmT,SAASpO,WAAW,0BACzB/E,KAAKmT,SAASpO,WAAW,kBACzB/E,KAAKmT,SAASpO,WAAW,iBACrB/E,KAAK6N,OAAO/D,uBACd9J,KAAK6N,OAAO/D,sBAAsBmS,SAAQ,SAAA+D,GAAe,OAAAvX,EAAK0K,SAASpO,WAAWib,MAEpFhgB,KAAKgX,qBAAuB,KAE5BhX,KAAKkO,cAAc9L,KAAK,IAAIwG,EAAe,WAEtC5I,KAAK2J,YAGNoW,IAICjK,GAAa9V,KAAKkJ,uBAAvB,CAIA,IAAIS,EAEJ,IAAK3J,KAAKkR,oBAAoBlR,KAAK2J,WAC/B,MAAM,IAAIrC,MACN,0IAKR,GAAItH,KAAK2J,UAAU9B,QAAQ,OAAS,EAChC8B,EAAY3J,KAAK2J,UACZpE,QAAQ,mBAAoBuQ,GAC5BvQ,QAAQ,oBAAqBvF,KAAKgJ,cACpC,CAEH,IAAI3C,EAAS,IAAI4O,EAAAA,WAEba,IACAzP,EAASA,EAAOnB,IAAI,gBAAiB4Q,IAGzC,IAAMmK,EAAgBjgB,KAAKkJ,uBAAyBlJ,KAAKiJ,YACrDgX,IACA5Z,EAASA,EAAOnB,IAAI,2BAA4B+a,IAGpDtW,EACI3J,KAAK2J,WACJ3J,KAAK2J,UAAU9B,QAAQ,MAAQ,EAAI,IAAM,KAC1CxB,EAAOR,WAEf7F,KAAK6N,OAAOnC,QAAQ/B,KAMjB6D,EAAAtN,UAAAsa,mBAAP,WACI,IAAMD,EAAOva,KACb,OAAOA,KAAKkgB,cAAczd,MAAK,SAAUgY,GAErC,OADAF,EAAKpH,SAASlO,QAAQ,QAASwV,GACxBA,MAORjN,EAAAtN,UAAAigB,YAAP,WACIngB,KAAK0R,wBACL1R,KAAK2R,oBAEL3R,KAAKkW,mCACL,IAAMkK,EAAqBxJ,SAASE,eAAe9W,KAAK4K,yBACpDwV,GACAA,EAAmBC,SAGvBrgB,KAAK4Z,wBACL5Z,KAAKsZ,kCACL,IAAMgH,EAAoB1J,SAASE,eAAe9W,KAAKiL,wBACnDqV,GACAA,EAAkBD,UAIhB7S,EAAAtN,UAAAggB,YAAV,WAAA,IAAAzX,EAAAzI,KACI,OAAO,IAAI8B,SAAQ,SAACC,GAChB,GAAI0G,EAAKa,OACL,MAAM,IAAIhC,MACN,gEAUR,IAAMiZ,EAAa,qEACfC,EAAO,GACPrJ,EAAK,GAEHvK,EAAyB,oBAAT6T,KAAuB,KAAQA,KAAK7T,QAAU6T,KAAe,SACnF,GAAI7T,EAAQ,CACR,IAAI8T,EAAQ,IAAIvT,WAAWqT,GAC3B5T,EAAO+T,gBAAgBD,GACvBA,EAAQA,EAAM/a,KAAI,SAAAib,GAAK,OAAAL,EAAW3a,WAAWgb,EAAIL,EAAW5f,WAC5DwW,EAAK7J,OAAOC,aAAa7K,MAAM,KAAMge,QAErC,KAAO,EAAIF,KACPrJ,GAAMoJ,EAAWtN,KAAK4N,SAAWN,EAAW5f,OAAS,GAI7DoB,EAAQiE,EAAgBmR,QAIhB3J,EAAAtN,UAAAkf,YAAhB,SAA4B/Y,sEACxB,OAAKrG,KAAK4N,uBAMV,CAAA,EAAO5N,KAAK4N,uBAAuBxH,eAAeC,KAL9CrG,KAAK+N,OAAOoG,KACR,+DAEJ,CAAA,GAAO,WAKL3G,EAAAtN,UAAAgf,eAAV,SAAyB7Y,GACrB,OAAKrG,KAAK4N,uBAMH5N,KAAK4N,uBAAuBkT,kBAAkBza,IALjDrG,KAAK+N,OAAOoG,KACR,iEAEGrS,QAAQC,QAAQ,QAUxByL,EAAAtN,UAAA6gB,cAAP,SACI5F,EACA9U,GAEA,YAHA,IAAA8U,IAAAA,EAAA,SACA,IAAA9U,IAAAA,EAAA,IAE0B,SAAtBrG,KAAKgK,aACEhK,KAAK0Q,aAAayK,EAAiB9U,GAEnCrG,KAAK2Q,iBAAiBwK,EAAiB9U,IAQ/CmH,EAAAtN,UAAAwQ,aAAP,SACIyK,EACA9U,GAFJ,IAAAoC,EAAAzI,UACI,IAAAmb,IAAAA,EAAA,SACA,IAAA9U,IAAAA,EAAA,IAEsB,KAAlBrG,KAAKmJ,SACLnJ,KAAKghB,qBAAqB7F,EAAiB9U,GAE3CrG,KAAK0O,OAAOa,KAAKC,EAAAA,QAAO,SAAAnN,GAAK,MAAW,8BAAXA,EAAEiG,SAC1BmH,WAAU,SAAAxM,GAAK,OAAAwF,EAAKuY,qBAAqB7F,EAAiB9U,OAI/DmH,EAAAtN,UAAA8gB,qBAAR,SACI7F,EACA9U,GAGA,QAJA,IAAA8U,IAAAA,EAAA,SACA,IAAA9U,IAAAA,EAAA,KAGKrG,KAAKkR,oBAAoBlR,KAAKmJ,UAC/B,MAAM,IAAI7B,MAAM,yIAGpBtH,KAAKoX,eAAe+D,EAAiB,GAAI,MAAM,EAAO9U,GACjD5D,KAAKzC,KAAK6N,OAAOnC,SACjBuE,OAAM,SAAAzL,GACH0C,QAAQ1C,MAAM,sCACd0C,QAAQ1C,MAAMA,OAIVgJ,EAAAtN,UAAA0a,mCAAhB,6GAEI,IAAK5a,KAAK4M,OACN,MAAM,IAAItF,MAAM,qGAIH,MAAA,CAAA,EAAMtH,KAAKkgB,sBACP,OADfpF,EAAWlU,EAAAzD,OACI,CAAA,EAAMnD,KAAK4M,OAAOnG,SAASqU,EAAU,mBAG1D,OAHMmG,EAAera,EAAAzD,OAGrB,CAAA,EAAO,CAFW6C,EAAgBib,GAEfnG,YAGftN,EAAAtN,UAAA0V,kCAAR,SAA0CL,GACxC,IAAI2L,EAAuC,IAAItc,IAC/C,OAAK5E,KAAK6N,OAAO/D,uBAGjB9J,KAAK6N,OAAO/D,sBAAsBmS,SAAQ,SAACkF,GACnC5L,EAAc4L,IAChBD,EAAgBhc,IAAIic,EAAqBpM,KAAKC,UAAUO,EAAc4L,QAGrED,GAPEA,4CA3sEWE,EAAAA,cACFC,EAAAA,kBACKC,EAAYjhB,WAAA,CAAA,CAAAiI,KAAhCiZ,EAAAA,kBACmCrb,EAAiB7F,WAAA,CAAA,CAAAiI,KAApDiZ,EAAAA,kBAC6BxS,EAAU1O,WAAA,CAAA,CAAAiI,KAAvCiZ,EAAAA,kBACoBha,SACHia,SACYnV,EAAWhM,WAAA,CAAA,CAAAiI,KAAxCiZ,EAAAA,cAxDI/T,EAAYpN,EAAA,CADxB+E,EAAAA,aAoDQjE,EAAA,EAAAqgB,EAAAA,YACArgB,EAAA,EAAAqgB,EAAAA,YACArgB,EAAA,EAAAqgB,EAAAA,YAGArgB,EAAA,EAAAqgB,EAAAA,mCAPiBH,EAAAA,OACFC,EAAAA,WACKC,EACepb,EACN6I,EACTxH,EACHia,EACYnV,KAxDzBmB,GAAb,CAAkCuB,KCpClC,eAIA,eCDA,0BAIA,SAAA0S,KAKA,OAHEA,EAAAvhB,UAAAwhB,YAAA,SAAYxN,GACV,OAAOyN,EAAAA,WAAWzN,IAEtBuN,kBCMI,SAAAG,EACYC,EACAC,EACAC,EACYC,GAHZhiB,KAAA6hB,YAAAA,EACA7hB,KAAA8hB,aAAAA,EACA9hB,KAAA+hB,aAAAA,EACY/hB,KAAAgiB,aAAAA,EA2D5B,OAxDYJ,EAAA1hB,UAAA+hB,SAAR,SAAiBlR,GACb,OAAI/Q,KAAKgiB,aAAaE,eAAeC,oBAC1BniB,KAAKgiB,aAAaE,eAAeC,oBAAoBpR,IAG5D/Q,KAAKgiB,aAAaE,eAAeE,eACxBpiB,KAAKgiB,aAAaE,eAAeE,YAAYC,MAAK,SAAAC,GAAK,OAAAvR,EAAIQ,WAAW+Q,OAMlFV,EAAA1hB,UAAAqiB,UAAP,SACEC,EACApgB,GAFF,IAAAqG,EAAAzI,KAIQ+Q,EAAMyR,EAAIzR,IAAIO,cAGpB,OAAKtR,KAAKgiB,cAAiBhiB,KAAKgiB,aAAaE,gBAAmBliB,KAAKiiB,SAASlR,GAItD/Q,KAAKgiB,aAAaE,eAAeO,gBAQlDC,EAAAA,MACLlQ,EAAAA,GAAGxS,KAAK8hB,aAAanN,kBAAkBpF,KACrCC,EAAAA,QAAO,SAAAmT,GAAS,QAAAA,MAElB3iB,KAAK8hB,aAAapT,OAAOa,KACvBC,EAAAA,QAAO,SAAAnN,GAAK,MAAW,mBAAXA,EAAEiG,QACd8J,EAAAA,QAAQpS,KAAK8hB,aAAatW,oBAAsB,GAChDoX,EAAAA,YAAW,SAAA3f,GAAK,OAAAuP,EAAAA,GAAG,SACnB7M,EAAAA,KAAI,SAAA1C,GAAK,OAAAwF,EAAKqZ,aAAanN,sBAE7BpF,KACAsT,EAAAA,KAAK,GACLC,EAAAA,UAAS,SAAAH,GACP,GAAIA,EAAO,CACT,IAAMzN,EAAS,UAAYyN,EACrBpO,EAAUiO,EAAIjO,QAAQrP,IAAI,gBAAiBgQ,GACjDsN,EAAMA,EAAIO,MAAM,CAAExO,QAAOA,IAG3B,OAAOnS,EACJ4gB,OAAOR,GACPjT,KAAKqT,EAAAA,YAAW,SAAA1O,GAAO,OAAAzL,EAAKsZ,aAAaL,YAAYxN,WA1BnD9R,EACJ4gB,OAAOR,GACPjT,KAAKqT,EAAAA,YAAW,SAAA1O,GAAO,OAAAzL,EAAKsZ,aAAaL,YAAYxN,OARjD9R,EAAK4gB,OAAOR,6CA1BIlB,SACC9T,SACAyV,SACYC,EAAiB7iB,WAAA,CAAA,CAAAiI,KAAlDiZ,EAAAA,cANIK,EAAuBxhB,EAAA,CADnC+E,EAAAA,aAOQjE,EAAA,EAAAqgB,EAAAA,mCAHoBD,EACC9T,EACAyV,EACYC,KAN7BtB,MCVbuB,EAAA,WAAA,SAAAA,KAOA,OANEA,EAAAjjB,UAAA4gB,kBAAA,SAAkB9B,GAChB,OAAOld,QAAQC,QAAQ,OAEzBohB,EAAAjjB,UAAAkG,eAAA,SAAe4Y,GACb,OAAOld,QAAQC,SAAQ,IAE3BohB,EAPA,YCJgBC,IACZ,OAAOlc,QAGX,SAAgBmc,IACZ,MAAiC,oBAAnBxU,eAAiCA,eAAiB,IAAInK,mBCiBxE,SAAA4e,WA2BA,SA3BaA,EACJA,EAAAC,QAAP,SACE1V,EACA2V,GAEA,YAHA,IAAA3V,IAAAA,EAAA,WACA,IAAA2V,IAAAA,EAAAL,GAEO,CACLM,SAAUC,EACVC,UAAW,CACTnW,EACAjG,EACA,CAAEqc,QAASpC,EAAaqC,WAAYT,GACpC,CAAEQ,QAAStC,EAAcuC,WAAYR,GACrC,CAAEO,QAAS1d,EAAmB4d,SAAUN,GACxC,CAAEI,QAASvX,EAAayX,SAAUxX,GAClC,CACEsX,QAASX,EACTa,SAAUrC,GAEZ,CAAEmC,QAASV,EAAmBa,SAAUlW,GACxC,CACE+V,QAASI,EAAAA,kBACTF,SAAUlC,EACVqC,OAAO,MAtBJX,EAAWI,EAAAtjB,EAAA,CALvB8jB,EAAAA,SAAS,CACRC,QAAS,CAACC,EAAAA,cACVC,aAAc,GACdC,QAAS,MAEEhB,MCAbiB,EAAA,SAAA7b,GAEE,SAAA6b,IAAA,IAAA9b,EACEC,EAAA3E,KAAA/D,OAAOA,YACPkH,QAAQ1C,MA1BA,8lBA6BZ,OAP2C1E,EAAAykB,EAAA7b,GAO3C6b,EAPA,CAA2CpB,GCrB9BqB,EAAc,IAAIC,EAAAA,eAA2B","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Injectable } from \"@angular/core\";\n\n/**\n * Additional options that can be passed to tryLogin.\n */\nexport class LoginOptions {\n  /**\n   * Is called, after a token has been received and\n   * successfully validated.\n   *\n   * Deprecated:  Use property ``events`` on OAuthService instead.\n   */\n  onTokenReceived?: (receivedTokens: ReceivedTokens) => void;\n\n  /**\n   * Hook, to validate the received tokens.\n   *\n   * Deprecated:  Use property ``tokenValidationHandler`` on OAuthService instead.\n   */\n  validationHandler?: (receivedTokens: ReceivedTokens) => Promise<any>;\n\n  /**\n   * Called when tryLogin detects that the auth server\n   * included an error message into the hash fragment.\n   *\n   * Deprecated:  Use property ``events`` on OAuthService instead.\n   */\n  onLoginError?: (params: object) => void;\n\n  /**\n   * A custom hash fragment to be used instead of the\n   * actual one. This is used for silent refreshes, to\n   * pass the iframes hash fragment to this method, and\n   * is also used by popup flows in the same manner.\n   * This can be used with code flow, where is must be set\n   * to a hash symbol followed by the querystring. The\n   * question mark is optional, but may be present following\n   * the hash symbol.\n   */\n  customHashFragment?: string;\n\n  /**\n   * Set this to true to disable the oauth2 state\n   * check which is a best practice to avoid\n   * security attacks.\n   * As OIDC defines a nonce check that includes\n   * this, this can be set to true when only doing\n   * OIDC.\n   */\n  disableOAuth2StateCheck?: boolean;\n\n  /**\n   * Normally, you want to clear your hash fragment after\n   * the lib read the token(s) so that they are not displayed\n   * anymore in the url. If not, set this to true. For code flow\n   * this controls removing query string values.\n   */\n  preventClearHashAfterLogin? = false;\n\n  /**\n   * Set this for code flow if you used a custom redirect Uri\n   * when retrieving the code. This is used internally for silent\n   * refresh and popup flows.\n   */\n  customRedirectUri?: string;\n}\n\n/**\n * Defines the logging interface the OAuthService uses\n * internally. Is compatible with the `console` object,\n * but you can provide your own implementation as well\n * through dependency injection.\n */\nexport abstract class OAuthLogger {\n  abstract debug(message?: any, ...optionalParams: any[]): void;\n  abstract info(message?: any, ...optionalParams: any[]): void;\n  abstract log(message?: any, ...optionalParams: any[]): void;\n  abstract warn(message?: any, ...optionalParams: any[]): void;\n  abstract error(message?: any, ...optionalParams: any[]): void;\n}\n\n/**\n * Defines a simple storage that can be used for\n * storing the tokens at client side.\n * Is compatible to localStorage and sessionStorage,\n * but you can also create your own implementations.\n */\nexport abstract class OAuthStorage {\n  abstract getItem(key: string): string | null;\n  abstract removeItem(key: string): void;\n  abstract setItem(key: string, data: string): void;\n}\n\n@Injectable()\nexport class MemoryStorage implements OAuthStorage {\n  private data = new Map<string, string>();\n\n  getItem(key: string): string {\n    return this.data.get(key);\n  }\n\n  removeItem(key: string): void {\n    this.data.delete(key);\n  }\n\n  setItem(key: string, data: string): void {\n    this.data.set(key, data);\n  }\n\n}\n\n/**\n * Represents the received tokens, the received state\n * and the parsed claims from the id-token.\n */\nexport class ReceivedTokens {\n  idToken: string;\n  accessToken: string;\n  idClaims?: object;\n  state?: string;\n}\n\n/**\n * Represents the parsed and validated id_token.\n */\nexport interface ParsedIdToken {\n  idToken: string;\n  idTokenClaims: object;\n  idTokenHeader: object;\n  idTokenClaimsJson: string;\n  idTokenHeaderJson: string;\n  idTokenExpiresAt: number;\n}\n\n/**\n * Represents the response from the token endpoint\n * http://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint\n */\nexport interface TokenResponse {\n  access_token: string;\n  id_token: string; \n  token_type: string;\n  expires_in: number;\n  refresh_token: string;\n  scope: string;\n  state?: string;\n}\n\n/**\n * Represents the response from the user info endpoint\n * http://openid.net/specs/openid-connect-core-1_0.html#UserInfo\n */\nexport interface UserInfo {\n  sub: string;\n  [key: string]: any;\n}\n\n/**\n * Represents an OpenID Connect discovery document\n */\nexport interface OidcDiscoveryDoc {\n  issuer: string;\n  authorization_endpoint: string;\n  token_endpoint: string;\n  token_endpoint_auth_methods_supported: string[];\n  token_endpoint_auth_signing_alg_values_supported: string[];\n  userinfo_endpoint: string;\n  check_session_iframe: string;\n  end_session_endpoint: string;\n  jwks_uri: string;\n  registration_endpoint: string;\n  scopes_supported: string[];\n  response_types_supported: string[];\n  acr_values_supported: string[];\n  response_modes_supported: string[];\n  grant_types_supported: string[];\n  subject_types_supported: string[];\n  userinfo_signing_alg_values_supported: string[];\n  userinfo_encryption_alg_values_supported: string[];\n  userinfo_encryption_enc_values_supported: string[];\n  id_token_signing_alg_values_supported: string[];\n  id_token_encryption_alg_values_supported: string[];\n  id_token_encryption_enc_values_supported: string[];\n  request_object_signing_alg_values_supported: string[];\n  display_values_supported: string[];\n  claim_types_supported: string[];\n  claims_supported: string[];\n  claims_parameter_supported: boolean;\n  service_documentation: string;\n  ui_locales_supported: string[];\n}\n","// see: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22\nexport function b64DecodeUnicode(str) {\n  const base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\n\n  return decodeURIComponent(\n    atob(base64)\n      .split('')\n      .map(function(c) {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n      })\n      .join('')\n  );\n}\n\nexport function base64UrlEncode(str): string {\n  const base64 = btoa(str);\n  return base64\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n}","import { base64UrlEncode } from '../base64-helper';\n\nexport interface ValidationParams {\n  idToken: string;\n  accessToken: string;\n  idTokenHeader: object;\n  idTokenClaims: object;\n  jwks: object;\n  loadKeys: () => Promise<object>;\n}\n\n/**\n * Interface for Handlers that are hooked in to\n * validate tokens.\n */\nexport abstract class ValidationHandler {\n  /**\n   * Validates the signature of an id_token.\n   */\n  public abstract validateSignature(\n    validationParams: ValidationParams\n  ): Promise<any>;\n\n  /**\n   * Validates the at_hash in an id_token against the received access_token.\n   */\n  public abstract validateAtHash(validationParams: ValidationParams): Promise<boolean>;\n}\n\n/**\n * This abstract implementation of ValidationHandler already implements\n * the method validateAtHash. However, to make use of it,\n * you have to override the method calcHash.\n */\nexport abstract class AbstractValidationHandler implements ValidationHandler {\n  /**\n   * Validates the signature of an id_token.\n   */\n  abstract validateSignature(validationParams: ValidationParams): Promise<any>;\n\n  /**\n   * Validates the at_hash in an id_token against the received access_token.\n   */\n  async validateAtHash(params: ValidationParams): Promise<boolean> {\n    let hashAlg = this.inferHashAlgorithm(params.idTokenHeader);\n\n    let tokenHash = await this.calcHash(params.accessToken, hashAlg); // sha256(accessToken, { asString: true });\n\n    let leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);\n\n    let atHash = base64UrlEncode(leftMostHalf);\n\n    let claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');\n\n    if (atHash !== claimsAtHash) {\n      console.error('exptected at_hash: ' + atHash);\n      console.error('actual at_hash: ' + claimsAtHash);\n    }\n\n    return atHash === claimsAtHash;\n  }\n\n  /**\n   * Infers the name of the hash algorithm to use\n   * from the alg field of an id_token.\n   *\n   * @param jwtHeader the id_token's parsed header\n   */\n  protected inferHashAlgorithm(jwtHeader: object): string {\n    let alg: string = jwtHeader['alg'];\n\n    if (!alg.match(/^.S[0-9]{3}$/)) {\n      throw new Error('Algorithm not supported: ' + alg);\n    }\n\n    return 'sha-' + alg.substr(2);\n  }\n\n  /**\n   * Calculates the hash for the passed value by using\n   * the passed hash algorithm.\n   *\n   * @param valueToHash\n   * @param algorithm\n   */\n  protected abstract calcHash(valueToHash: string, algorithm: string): Promise<string>;\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class UrlHelperService {\n  public getHashFragmentParams(customHashFragment?: string): object {\n    let hash = customHashFragment || window.location.hash;\n\n    hash = decodeURIComponent(hash);\n\n    if (hash.indexOf('#') !== 0) {\n      return {};\n    }\n\n    const questionMarkPosition = hash.indexOf('?');\n\n    if (questionMarkPosition > -1) {\n      hash = hash.substr(questionMarkPosition + 1);\n    } else {\n      hash = hash.substr(1);\n    }\n\n    return this.parseQueryString(hash);\n  }\n\n  public parseQueryString(queryString: string): object {\n    const data = {};\n    let\n      pairs,\n      pair,\n      separatorIndex,\n      escapedKey,\n      escapedValue,\n      key,\n      value;\n\n    if (queryString === null) {\n      return data;\n    }\n\n    pairs = queryString.split('&');\n\n    for (let i = 0; i < pairs.length; i++) {\n      pair = pairs[i];\n      separatorIndex = pair.indexOf('=');\n\n      if (separatorIndex === -1) {\n        escapedKey = pair;\n        escapedValue = null;\n      } else {\n        escapedKey = pair.substr(0, separatorIndex);\n        escapedValue = pair.substr(separatorIndex + 1);\n      }\n\n      key = decodeURIComponent(escapedKey);\n      value = decodeURIComponent(escapedValue);\n\n      if (key.substr(0, 1) === '/') { key = key.substr(1); }\n\n      data[key] = value;\n    }\n\n    return data;\n  }\n}\n","export type EventType =\n  | 'discovery_document_loaded'\n  | 'jwks_load_error'\n  | 'invalid_nonce_in_state'\n  | 'discovery_document_load_error'\n  | 'discovery_document_validation_error'\n  | 'user_profile_loaded'\n  | 'user_profile_load_error'\n  | 'token_received'\n  | 'token_error'\n  | 'code_error'\n  | 'token_refreshed'\n  | 'token_refresh_error'\n  | 'silent_refresh_error'\n  | 'silently_refreshed'\n  | 'silent_refresh_timeout'\n  | 'token_validation_error'\n  | 'token_expires'\n  | 'session_changed'\n  | 'session_error'\n  | 'session_terminated'\n  | 'logout'\n  | 'popup_closed'\n  | 'popup_blocked';\n\nexport abstract class OAuthEvent {\n  constructor(readonly type: EventType) {}\n}\n\nexport class OAuthSuccessEvent extends OAuthEvent {\n  constructor(type: EventType, readonly info: any = null) {\n    super(type);\n  }\n}\n\nexport class OAuthInfoEvent extends OAuthEvent {\n  constructor(type: EventType, readonly info: any = null) {\n    super(type);\n  }\n}\n\nexport class OAuthErrorEvent extends OAuthEvent {\n  constructor(\n    type: EventType,\n    readonly reason: object,\n    readonly params: object = null\n  ) {\n    super(type);\n  }\n}\n","export class AuthConfig {\n  /**\n   * The client's id as registered with the auth server\n   */\n  public clientId? = '';\n\n  /**\n   * The client's redirectUri as registered with the auth server\n   */\n  public redirectUri? = '';\n\n  /**\n   * An optional second redirectUri where the auth server\n   * redirects the user to after logging out.\n   */\n  public postLogoutRedirectUri? = '';\n\n  /**\n   * The auth server's endpoint that allows to log\n   * the user in when using implicit flow.\n   */\n  public loginUrl? = '';\n\n  /**\n   * The requested scopes\n   */\n  public scope? = 'openid profile';\n\n  public resource? = '';\n\n  public rngUrl? = '';\n\n  /**\n   * Defines whether to use OpenId Connect during\n   * implicit flow.\n   */\n  public oidc? = true;\n\n  /**\n   * Defines whether to request an access token during\n   * implicit flow.\n   */\n  public requestAccessToken? = true;\n\n  public options?: any = null;\n\n  /**\n   * The issuer's uri.\n   */\n  public issuer? = '';\n\n  /**\n   * The logout url.\n   */\n  public logoutUrl? = '';\n\n  /**\n   * Defines whether to clear the hash fragment after logging in.\n   */\n  public clearHashAfterLogin? = true;\n\n  /**\n   * Url of the token endpoint as defined by OpenId Connect and OAuth 2.\n   */\n  public tokenEndpoint?: string = null;\n\n  /**\n   * Names of known parameters sent out in the TokenResponse. https://tools.ietf.org/html/rfc6749#section-5.1\n   */\n  public customTokenParameters?: string[] = [];\n\n  /**\n   * Url of the userinfo endpoint as defined by OpenId Connect.\n   */\n  public userinfoEndpoint?: string = null;\n\n  public responseType? = '';\n\n  /**\n   * Defines whether additional debug information should\n   * be shown at the console. Note that in certain browsers\n   * the verbosity of the console needs to be explicitly set\n   * to include Debug level messages.\n   */\n   public showDebugInformation? = false;\n\n  /**\n   * The redirect uri used when doing silent refresh.\n   */\n  public silentRefreshRedirectUri? = '';\n\n  public silentRefreshMessagePrefix? = '';\n\n  /**\n   * Set this to true to display the iframe used for\n   * silent refresh for debugging.\n   */\n  public silentRefreshShowIFrame? = false;\n\n  /**\n   * Timeout for silent refresh.\n   * @internal\n   * depreacted b/c of typo, see silentRefreshTimeout\n   */\n  public siletRefreshTimeout?: number = 1000 * 20;\n\n  /**\n   * Timeout for silent refresh.\n   */\n  public silentRefreshTimeout?: number = 1000 * 20;\n\n  /**\n   * Some auth servers don't allow using password flow\n   * w/o a client secret while the standards do not\n   * demand for it. In this case, you can set a password\n   * here. As this password is exposed to the public\n   * it does not bring additional security and is therefore\n   * as good as using no password.\n   */\n  public dummyClientSecret?: string = null;\n\n  /**\n   * Defines whether https is required.\n   * The default value is remoteOnly which only allows\n   * http for localhost, while every other domains need\n   * to be used with https.\n   */\n  public requireHttps?: boolean | 'remoteOnly' = 'remoteOnly';\n\n  /**\n   * Defines whether every url provided by the discovery\n   * document has to start with the issuer's url.\n   */\n  public strictDiscoveryDocumentValidation? = true;\n\n  /**\n   * JSON Web Key Set (https://tools.ietf.org/html/rfc7517)\n   * with keys used to validate received id_tokens.\n   * This is taken out of the disovery document. Can be set manually too.\n   */\n  public jwks?: object = null;\n\n  /**\n   * Map with additional query parameter that are appended to\n   * the request when initializing implicit flow.\n   */\n  public customQueryParams?: object = null;\n\n  public silentRefreshIFrameName? = 'angular-oauth-oidc-silent-refresh-iframe';\n\n  /**\n   * Defines when the token_timeout event should be raised.\n   * If you set this to the default value 0.75, the event\n   * is triggered after 75% of the token's life time.\n   */\n  public timeoutFactor? = 0.75;\n\n  /**\n   * If true, the lib will try to check whether the user\n   * is still logged in on a regular basis as described\n   * in http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\n   */\n  public sessionChecksEnabled? = false;\n\n  /**\n   * Interval in msec for checking the session\n   * according to http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\n   */\n  public sessionCheckIntervall? = 3 * 1000;\n\n  /**\n   * Url for the iframe used for session checks\n   */\n  public sessionCheckIFrameUrl?: string = null;\n\n  /**\n   * Name of the iframe to use for session checks\n   */\n  public sessionCheckIFrameName? = 'angular-oauth-oidc-check-session-iframe';\n\n  /**\n   * This property has been introduced to disable at_hash checks\n   * and is indented for Identity Provider that does not deliver\n   * an at_hash EVEN THOUGH its recommended by the OIDC specs.\n   * Of course, when disabling these checks the we are bypassing\n   * a security check which means we are more vulnerable.\n   */\n  public disableAtHashCheck? = false;\n\n  /**\n   * Defines wether to check the subject of a refreshed token after silent refresh.\n   * Normally, it should be the same as before.\n   */\n  public skipSubjectCheck? = false;\n\n  public useIdTokenHintForSilentRefresh? = false;\n\n  /**\n   * Defined whether to skip the validation of the issuer in the discovery document.\n   * Normally, the discovey document's url starts with the url of the issuer.\n   */\n  public skipIssuerCheck? = false;\n\n  /**\n   * According to rfc6749 it is recommended (but not required) that the auth\n   * server exposes the access_token's life time in seconds.\n   * This is a fallback value for the case this value is not exposed.\n   */\n  public fallbackAccessTokenExpirationTimeInSec?: number;\n\n  /**\n   * final state sent to issuer is built as follows:\n   * state = nonce + nonceStateSeparator + additional state\n   * Default separator is ';' (encoded %3B).\n   * In rare cases, this character might be forbidden or inconvenient to use by the issuer so it can be customized.\n   */\n  public nonceStateSeparator? = ';';\n\n  /**\n   * Set this to true to use HTTP BASIC auth for password flow\n   */\n  public useHttpBasicAuth? = false;\n\n  /**\n   * The window of time (in seconds) to allow the current time to deviate when validating id_token's iat and exp values.\n   */\n  public clockSkewInSec?: number;\n\n  /**\n   * The interceptors waits this time span if there is no token\n  */\n  public waitForTokenInMsec? = 0;\n\n  /**\n   * Code Flow is by defauld used together with PKCI which is also higly recommented.\n   * You can disbale it here by setting this flag to true.\n   * https://tools.ietf.org/html/rfc7636#section-1.1\n   */\n  public disablePKCE? = false;\n\n  constructor(json?: Partial<AuthConfig>) {\n    if (json) {\n      Object.assign(this, json);\n    }\n  }\n\n  /**\n   * This property allows you to override the method that is used to open the login url,\n   * allowing a way for implementations to specify their own method of routing to new\n   * urls.\n   */\n  public openUri?: ((uri: string) => void) = uri => {\n    location.href = uri;\n  }\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n/**\n * This custom encoder allows charactes like +, % and / to be used in passwords\n */\nexport class WebHttpUrlEncodingCodec implements HttpParameterCodec {\n  encodeKey(k: string): string {\n    return encodeURIComponent(k);\n  }\n\n  encodeValue(v: string): string {\n    return encodeURIComponent(v);\n  }\n\n  decodeKey(k: string): string {\n    return decodeURIComponent(k);\n  }\n\n  decodeValue(v: string) {\n    return decodeURIComponent(v);\n  }\n}\n","import { Injectable } from '@angular/core';\n\n/**\n * Abstraction for crypto algorithms\n*/\nexport abstract class HashHandler {\n    abstract calcHash(valueToHash: string, algorithm: string): Promise<string>;\n}\n\n@Injectable()\nexport class DefaultHashHandler implements HashHandler {\n\n    async calcHash(valueToHash: string, algorithm: string): Promise<string> {\n        const encoder = new TextEncoder();\n        const data = encoder.encode(valueToHash);\n        const hashArray = await window.crypto.subtle.digest(algorithm, data);\n        return this.toHashString(hashArray);\n    }\n\n    toHashString(buffer: ArrayBuffer) {\n      const byteArray = new Uint8Array(buffer);\n      let result = '';\n      for (let e of byteArray) {\n        result += String.fromCharCode(e);\n      }\n      return result;\n    }\n\n    // hexString(buffer) {\n    //     const byteArray = new Uint8Array(buffer);\n    //     const hexCodes = [...byteArray].map(value => {\n    //       const hexCode = value.toString(16);\n    //       const paddedHexCode = hexCode.padStart(2, '0');\n    //       return paddedHexCode;\n    //     });\n      \n    //     return hexCodes.join('');\n    //   }\n    \n      // toHashString(hexString: string) {\n      //   let result = '';\n      //   for (let i = 0; i < hexString.length; i += 2) {\n      //     let hexDigit = hexString.charAt(i) + hexString.charAt(i + 1);\n      //     let num = parseInt(hexDigit, 16);\n      //     result += String.fromCharCode(num);\n      //   }\n      //   return result;\n      // }\n\n}","import { Injectable, NgZone, Optional, OnDestroy } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';\nimport { Observable, Subject, Subscription, of, race, from } from 'rxjs';\nimport { filter, delay, first, tap, map, switchMap, debounceTime } from 'rxjs/operators';\n\nimport {\n    ValidationHandler,\n    ValidationParams\n} from './token-validation/validation-handler';\nimport { UrlHelperService } from './url-helper.service';\nimport {\n    OAuthEvent,\n    OAuthInfoEvent,\n    OAuthErrorEvent,\n    OAuthSuccessEvent\n} from './events';\nimport {\n    OAuthLogger,\n    OAuthStorage,\n    LoginOptions,\n    ParsedIdToken,\n    OidcDiscoveryDoc,\n    TokenResponse,\n    UserInfo\n} from './types';\nimport { b64DecodeUnicode, base64UrlEncode } from './base64-helper';\nimport { AuthConfig } from './auth.config';\nimport { WebHttpUrlEncodingCodec } from './encoder';\nimport { HashHandler } from './token-validation/hash-handler';\n\n/**\n * Service for logging in and logging out with\n * OIDC and OAuth2. Supports implicit flow and\n * password flow.\n */\n@Injectable()\nexport class OAuthService extends AuthConfig implements OnDestroy {\n    // Extending AuthConfig ist just for LEGACY reasons\n    // to not break existing code.\n\n    /**\n     * The ValidationHandler used to validate received\n     * id_tokens.\n     */\n    public tokenValidationHandler: ValidationHandler;\n\n    /**\n     * @internal\n     * Deprecated:  use property events instead\n     */\n    public discoveryDocumentLoaded = false;\n\n    /**\n     * @internal\n     * Deprecated:  use property events instead\n     */\n    public discoveryDocumentLoaded$: Observable<OidcDiscoveryDoc>;\n\n    /**\n     * Informs about events, like token_received or token_expires.\n     * See the string enum EventType for a full list of event types.\n     */\n    public events: Observable<OAuthEvent>;\n\n    /**\n     * The received (passed around) state, when logging\n     * in with implicit flow.\n     */\n    public state?= '';\n\n    protected eventsSubject: Subject<OAuthEvent> = new Subject<OAuthEvent>();\n    protected discoveryDocumentLoadedSubject: Subject<OidcDiscoveryDoc> = new Subject<OidcDiscoveryDoc>();\n    protected silentRefreshPostMessageEventListener: EventListener;\n    protected grantTypesSupported: Array<string> = [];\n    protected _storage: OAuthStorage;\n    protected accessTokenTimeoutSubscription: Subscription;\n    protected idTokenTimeoutSubscription: Subscription;\n    protected tokenReceivedSubscription: Subscription;\n    protected sessionCheckEventListener: EventListener;\n    protected jwksUri: string;\n    protected sessionCheckTimer: any;\n    protected silentRefreshSubject: string;\n    protected inImplicitFlow = false;\n\n    constructor(\n        protected ngZone: NgZone,\n        protected http: HttpClient,\n        @Optional() storage: OAuthStorage,\n        @Optional() tokenValidationHandler: ValidationHandler,\n        @Optional() protected config: AuthConfig,\n        protected urlHelper: UrlHelperService,\n        protected logger: OAuthLogger,\n        @Optional() protected crypto: HashHandler,\n    ) {\n        super();\n\n        this.debug('angular-oauth2-oidc v8-beta');\n\n        this.discoveryDocumentLoaded$ = this.discoveryDocumentLoadedSubject.asObservable();\n        this.events = this.eventsSubject.asObservable();\n\n        if (tokenValidationHandler) {\n            this.tokenValidationHandler = tokenValidationHandler;\n        }\n\n        if (config) {\n            this.configure(config);\n        }\n\n        try {\n            if (storage) {\n                this.setStorage(storage);\n            } else if (typeof sessionStorage !== 'undefined') {\n                this.setStorage(sessionStorage);\n            }\n        } catch (e) {\n\n            console.error(\n                'No OAuthStorage provided and cannot access default (sessionStorage).'\n                + 'Consider providing a custom OAuthStorage implementation in your module.',\n                e\n            );\n        }\n\n        this.setupRefreshTimer();\n    }\n\n    /**\n     * Use this method to configure the service\n     * @param config the configuration\n     */\n    public configure(config: AuthConfig): void {\n        // For the sake of downward compatibility with\n        // original configuration API\n        Object.assign(this, new AuthConfig(), config);\n\n        this.config = Object.assign({} as AuthConfig, new AuthConfig(), config);\n\n        if (this.sessionChecksEnabled) {\n            this.setupSessionCheck();\n        }\n\n        this.configChanged();\n    }\n\n    protected configChanged(): void {\n        this.setupRefreshTimer();\n    }\n\n    public restartSessionChecksIfStillLoggedIn(): void {\n        if (this.hasValidIdToken()) {\n            this.initSessionCheck();\n        }\n    }\n\n    protected restartRefreshTimerIfStillLoggedIn(): void {\n        this.setupExpirationTimers();\n    }\n\n    protected setupSessionCheck(): void {\n        this.events.pipe(filter(e => e.type === 'token_received')).subscribe(e => {\n            this.initSessionCheck();\n        });\n    }\n\n    /**\n     * Will setup up silent refreshing for when the token is\n     * about to expire. When the user is logged out via this.logOut method, the\n     * silent refreshing will pause and not refresh the tokens until the user is\n     * logged back in via receiving a new token.\n     * @param params Additional parameter to pass\n     * @param listenTo Setup automatic refresh of a specific token type\n     */\n    public setupAutomaticSilentRefresh(params: object = {}, listenTo?: 'access_token' | 'id_token' | 'any', noPrompt = true): void {\n        let shouldRunSilentRefresh = true;\n        this.events.pipe(\n            tap((e) => {\n                if (e.type === 'token_received') {\n                    shouldRunSilentRefresh = true;\n                } else if (e.type === 'logout') {\n                    shouldRunSilentRefresh = false;\n                }\n            }),\n            filter(e => e.type === 'token_expires'),\n            debounceTime(1000),\n        ).subscribe(e => {\n            const event = e as OAuthInfoEvent;\n            if ((listenTo == null || listenTo === 'any' || event.info === listenTo) && shouldRunSilentRefresh) {\n                // this.silentRefresh(params, noPrompt).catch(_ => {\n                this.refreshInternal(params, noPrompt).catch(_ => {\n                    this.debug('Automatic silent refresh did not work');\n                });\n            }\n        });\n\n        this.restartRefreshTimerIfStillLoggedIn();\n    }\n\n    protected refreshInternal(params, noPrompt): Promise<TokenResponse | OAuthEvent> {\n\n        if (!this.silentRefreshRedirectUri && this.responseType === 'code') {\n            return this.refreshToken();\n        } else {\n            return this.silentRefresh(params, noPrompt);\n        }\n    }\n\n    /**\n     * Convenience method that first calls `loadDiscoveryDocument(...)` and\n     * directly chains using the `then(...)` part of the promise to call\n     * the `tryLogin(...)` method.\n     *\n     * @param options LoginOptions to pass through to `tryLogin(...)`\n     */\n    public loadDiscoveryDocumentAndTryLogin(options: LoginOptions = null): Promise<boolean> {\n        return this.loadDiscoveryDocument().then(doc => {\n            return this.tryLogin(options);\n        });\n    }\n\n    /**\n     * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\n     * and if then chains to `initLoginFlow()`, but only if there is no valid\n     * IdToken or no valid AccessToken.\n     *\n     * @param options LoginOptions to pass through to `tryLogin(...)`\n     */\n    public loadDiscoveryDocumentAndLogin(options: LoginOptions & { state?: string } = null): Promise<boolean> {\n        if (!options) {\n            options = { state: '' };\n        }\n        return this.loadDiscoveryDocumentAndTryLogin(options).then(_ => {\n            if (!this.hasValidIdToken() || !this.hasValidAccessToken()) {\n                if (this.responseType === 'code') {\n                    this.initCodeFlow();\n                } else {\n                    this.initImplicitFlow();\n                }\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n\n    protected debug(...args): void {\n        if (this.showDebugInformation) {\n            this.logger.debug.apply(this.logger, args);\n        }\n    }\n\n    protected validateUrlFromDiscoveryDocument(url: string): string[] {\n        const errors: string[] = [];\n        const httpsCheck = this.validateUrlForHttps(url);\n        const issuerCheck = this.validateUrlAgainstIssuer(url);\n\n        if (!httpsCheck) {\n            errors.push(\n                'https for all urls required. Also for urls received by discovery.'\n            );\n        }\n\n        if (!issuerCheck) {\n            errors.push(\n                'Every url in discovery document has to start with the issuer url.' +\n                'Also see property strictDiscoveryDocumentValidation.'\n            );\n        }\n\n        return errors;\n    }\n\n    protected validateUrlForHttps(url: string): boolean {\n        if (!url) {\n            return true;\n        }\n\n        const lcUrl = url.toLowerCase();\n\n        if (this.requireHttps === false) {\n            return true;\n        }\n\n        if (\n            (lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/) ||\n                lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/)) &&\n            this.requireHttps === 'remoteOnly'\n        ) {\n            return true;\n        }\n\n        return lcUrl.startsWith('https://');\n    }\n\n    protected assertUrlNotNullAndCorrectProtocol(url: string | undefined, description: string) {\n        if (!url) {\n            throw new Error(`'${description}' should not be null`);\n        }\n        if (!this.validateUrlForHttps(url)) {\n            throw new Error(`'${description}' must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).`);\n        }\n    }\n\n    protected validateUrlAgainstIssuer(url: string) {\n        if (!this.strictDiscoveryDocumentValidation) {\n            return true;\n        }\n        if (!url) {\n            return true;\n        }\n        return url.toLowerCase().startsWith(this.issuer.toLowerCase());\n    }\n\n    protected setupRefreshTimer(): void {\n        if (typeof window === 'undefined') {\n            this.debug('timer not supported on this plattform');\n            return;\n        }\n\n        if (this.hasValidIdToken() || this.hasValidAccessToken()) {\n            this.clearAccessTokenTimer();\n            this.clearIdTokenTimer();\n            this.setupExpirationTimers();\n        }\n\n        if (this.tokenReceivedSubscription)\n            this.tokenReceivedSubscription.unsubscribe();\n\n        this.tokenReceivedSubscription = this.events.pipe(filter(e => e.type === 'token_received')).subscribe(_ => {\n            this.clearAccessTokenTimer();\n            this.clearIdTokenTimer();\n            this.setupExpirationTimers();\n        });\n    }\n\n    protected setupExpirationTimers(): void {\n        if (this.hasValidAccessToken()) {\n            this.setupAccessTokenTimer();\n        }\n\n\n        if (this.hasValidIdToken()) {\n            this.setupIdTokenTimer();\n        }\n    }\n\n    protected setupAccessTokenTimer(): void {\n\n        const expiration = this.getAccessTokenExpiration();\n        const storedAt = this.getAccessTokenStoredAt();\n        const timeout = this.calcTimeout(storedAt, expiration);\n\n        this.ngZone.runOutsideAngular(() => {\n            this.accessTokenTimeoutSubscription = of(\n                new OAuthInfoEvent('token_expires', 'access_token')\n            )\n                .pipe(delay(timeout))\n                .subscribe(e => {\n                    this.ngZone.run(() => {\n                        this.eventsSubject.next(e);\n                    });\n                });\n        });\n    }\n\n    protected setupIdTokenTimer(): void {\n\n        const expiration = this.getIdTokenExpiration();\n        const storedAt = this.getIdTokenStoredAt();\n        const timeout = this.calcTimeout(storedAt, expiration);\n\n        this.ngZone.runOutsideAngular(() => {\n            this.idTokenTimeoutSubscription = of(\n                new OAuthInfoEvent('token_expires', 'id_token')\n            )\n                .pipe(delay(timeout))\n                .subscribe(e => {\n                    this.ngZone.run(() => {\n                        this.eventsSubject.next(e);\n                    });\n                });\n        });\n    }\n\n    protected clearAccessTokenTimer(): void {\n        if (this.accessTokenTimeoutSubscription) {\n            this.accessTokenTimeoutSubscription.unsubscribe();\n        }\n    }\n\n    protected clearIdTokenTimer(): void {\n        if (this.idTokenTimeoutSubscription) {\n            this.idTokenTimeoutSubscription.unsubscribe();\n        }\n    }\n\n    protected calcTimeout(storedAt: number, expiration: number): number {\n        const now = Date.now();\n        const delta = (expiration - storedAt) * this.timeoutFactor - (now - storedAt);\n        return Math.max(0, delta);\n    }\n\n    /**\n     * DEPRECATED. Use a provider for OAuthStorage instead:\n     *\n     * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\n     * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\n     * Sets a custom storage used to store the received\n     * tokens on client side. By default, the browser's\n     * sessionStorage is used.\n     * @ignore\n     *\n     * @param storage\n     */\n    public setStorage(storage: OAuthStorage): void {\n        this._storage = storage;\n        this.configChanged();\n    }\n\n    /**\n     * Loads the discovery document to configure most\n     * properties of this service. The url of the discovery\n     * document is infered from the issuer's url according\n     * to the OpenId Connect spec. To use another url you\n     * can pass it to to optional parameter fullUrl.\n     *\n     * @param fullUrl\n     */\n    public loadDiscoveryDocument(fullUrl: string = null): Promise<OAuthSuccessEvent> {\n        return new Promise((resolve, reject) => {\n            if (!fullUrl) {\n                fullUrl = this.issuer || '';\n                if (!fullUrl.endsWith('/')) {\n                    fullUrl += '/';\n                }\n                fullUrl += '.well-known/openid-configuration';\n            }\n\n            if (!this.validateUrlForHttps(fullUrl)) {\n                reject('issuer  must use HTTPS (with TLS), or config value for property \\'requireHttps\\' must be set to \\'false\\' and allow HTTP (without TLS).');\n                return;\n            }\n\n            this.http.get<OidcDiscoveryDoc>(fullUrl).subscribe(\n                doc => {\n                    if (!this.validateDiscoveryDocument(doc)) {\n                        this.eventsSubject.next(\n                            new OAuthErrorEvent('discovery_document_validation_error', null)\n                        );\n                        reject('discovery_document_validation_error');\n                        return;\n                    }\n\n                    this.loginUrl = doc.authorization_endpoint;\n                    this.logoutUrl = doc.end_session_endpoint || this.logoutUrl;\n                    this.grantTypesSupported = doc.grant_types_supported;\n                    this.issuer = doc.issuer;\n                    this.tokenEndpoint = doc.token_endpoint;\n                    this.userinfoEndpoint = doc.userinfo_endpoint || this.userinfoEndpoint;\n                    this.jwksUri = doc.jwks_uri;\n                    this.sessionCheckIFrameUrl = doc.check_session_iframe || this.sessionCheckIFrameUrl;\n\n                    this.discoveryDocumentLoaded = true;\n                    this.discoveryDocumentLoadedSubject.next(doc);\n\n                    if (this.sessionChecksEnabled) {\n                        this.restartSessionChecksIfStillLoggedIn();\n                    }\n\n                    this.loadJwks()\n                        .then(jwks => {\n                            const result: object = {\n                                discoveryDocument: doc,\n                                jwks: jwks\n                            };\n\n                            const event = new OAuthSuccessEvent(\n                                'discovery_document_loaded',\n                                result\n                            );\n                            this.eventsSubject.next(event);\n                            resolve(event);\n                            return;\n                        })\n                        .catch(err => {\n                            this.eventsSubject.next(\n                                new OAuthErrorEvent('discovery_document_load_error', err)\n                            );\n                            reject(err);\n                            return;\n                        });\n                },\n                err => {\n                    this.logger.error('error loading discovery document', err);\n                    this.eventsSubject.next(\n                        new OAuthErrorEvent('discovery_document_load_error', err)\n                    );\n                    reject(err);\n                }\n            );\n        });\n    }\n\n    protected loadJwks(): Promise<object> {\n        return new Promise<object>((resolve, reject) => {\n            if (this.jwksUri) {\n                this.http.get(this.jwksUri).subscribe(\n                    jwks => {\n                        this.jwks = jwks;\n                        this.eventsSubject.next(\n                            new OAuthSuccessEvent('discovery_document_loaded')\n                        );\n                        resolve(jwks);\n                    },\n                    err => {\n                        this.logger.error('error loading jwks', err);\n                        this.eventsSubject.next(\n                            new OAuthErrorEvent('jwks_load_error', err)\n                        );\n                        reject(err);\n                    }\n                );\n            } else {\n                resolve(null);\n            }\n        });\n    }\n\n    protected validateDiscoveryDocument(doc: OidcDiscoveryDoc): boolean {\n        let errors: string[];\n\n        if (!this.skipIssuerCheck && doc.issuer !== this.issuer) {\n            this.logger.error(\n                'invalid issuer in discovery document',\n                'expected: ' + this.issuer,\n                'current: ' + doc.issuer\n            );\n            return false;\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.authorization_endpoint);\n        if (errors.length > 0) {\n            this.logger.error(\n                'error validating authorization_endpoint in discovery document',\n                errors\n            );\n            return false;\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.end_session_endpoint);\n        if (errors.length > 0) {\n            this.logger.error(\n                'error validating end_session_endpoint in discovery document',\n                errors\n            );\n            return false;\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.token_endpoint);\n        if (errors.length > 0) {\n            this.logger.error(\n                'error validating token_endpoint in discovery document',\n                errors\n            );\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.userinfo_endpoint);\n        if (errors.length > 0) {\n            this.logger.error(\n                'error validating userinfo_endpoint in discovery document',\n                errors\n            );\n            return false;\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.jwks_uri);\n        if (errors.length > 0) {\n            this.logger.error('error validating jwks_uri in discovery document', errors);\n            return false;\n        }\n\n        if (this.sessionChecksEnabled && !doc.check_session_iframe) {\n            this.logger.warn(\n                'sessionChecksEnabled is activated but discovery document' +\n                ' does not contain a check_session_iframe field'\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Uses password flow to exchange userName and password for an\n     * access_token. After receiving the access_token, this method\n     * uses it to query the userinfo endpoint in order to get information\n     * about the user in question.\n     *\n     * When using this, make sure that the property oidc is set to false.\n     * Otherwise stricter validations take place that make this operation\n     * fail.\n     *\n     * @param userName\n     * @param password\n     * @param headers Optional additional http-headers.\n     */\n    public fetchTokenUsingPasswordFlowAndLoadUserProfile(\n        userName: string,\n        password: string,\n        headers: HttpHeaders = new HttpHeaders()\n    ): Promise<UserInfo> {\n        return this.fetchTokenUsingPasswordFlow(userName, password, headers).then(\n            () => this.loadUserProfile()\n        );\n    }\n\n    /**\n     * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\n     *\n     * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\n     * Otherwise stricter validations take place that make this operation fail.\n     */\n    public loadUserProfile(): Promise<UserInfo> {\n        if (!this.hasValidAccessToken()) {\n            throw new Error('Can not load User Profile without access_token');\n        }\n        if (!this.validateUrlForHttps(this.userinfoEndpoint)) {\n            throw new Error('userinfoEndpoint must use HTTPS (with TLS), or config value for property \\'requireHttps\\' must be set to \\'false\\' and allow HTTP (without TLS).');\n        }\n\n        return new Promise((resolve, reject) => {\n            const headers = new HttpHeaders().set(\n                'Authorization',\n                'Bearer ' + this.getAccessToken()\n            );\n\n            this.http.get<UserInfo>(this.userinfoEndpoint, { headers }).subscribe(\n                info => {\n                    this.debug('userinfo received', info);\n\n                    const existingClaims = this.getIdentityClaims() || {};\n\n                    if (!this.skipSubjectCheck) {\n                        if (\n                            this.oidc &&\n                            (!existingClaims['sub'] || info.sub !== existingClaims['sub'])\n                        ) {\n                            const err =\n                                'if property oidc is true, the received user-id (sub) has to be the user-id ' +\n                                'of the user that has logged in with oidc.\\n' +\n                                'if you are not using oidc but just oauth2 password flow set oidc to false';\n\n                            reject(err);\n                            return;\n                        }\n                    }\n\n                    info = Object.assign({}, existingClaims, info);\n\n                    this._storage.setItem('id_token_claims_obj', JSON.stringify(info));\n                    this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\n                    resolve(info);\n                },\n                err => {\n                    this.logger.error('error loading user info', err);\n                    this.eventsSubject.next(\n                        new OAuthErrorEvent('user_profile_load_error', err)\n                    );\n                    reject(err);\n                }\n            );\n        });\n    }\n\n    /**\n     * Uses password flow to exchange userName and password for an access_token.\n     * @param userName\n     * @param password\n     * @param headers Optional additional http-headers.\n     */\n    public fetchTokenUsingPasswordFlow(\n        userName: string,\n        password: string,\n        headers: HttpHeaders = new HttpHeaders()\n\n    ): Promise<TokenResponse> {\n        this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n\n        return new Promise((resolve, reject) => {\n            /**\n             * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\n             * serialize and parse URL parameter keys and values.\n             *\n             * @stable\n             */\n            let params = new HttpParams({ encoder: new WebHttpUrlEncodingCodec() })\n                .set('grant_type', 'password')\n                .set('scope', this.scope)\n                .set('username', userName)\n                .set('password', password);\n\n            if (this.useHttpBasicAuth) {\n                const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n                headers = headers.set(\n                    'Authorization',\n                    'Basic ' + header);\n            }\n\n            if (!this.useHttpBasicAuth) {\n                params = params.set('client_id', this.clientId);\n            }\n\n            if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n                params = params.set('client_secret', this.dummyClientSecret);\n            }\n\n            if (this.customQueryParams) {\n                for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n                    params = params.set(key, this.customQueryParams[key]);\n                }\n            }\n\n            headers = headers.set(\n                'Content-Type',\n                'application/x-www-form-urlencoded'\n            );\n\n            this.http\n                .post<TokenResponse>(this.tokenEndpoint, params, { headers })\n                .subscribe(\n                    tokenResponse => {\n                        this.debug('tokenResponse', tokenResponse);\n                        this.storeAccessTokenResponse(\n                            tokenResponse.access_token,\n                            tokenResponse.refresh_token,\n                            tokenResponse.expires_in,\n                            tokenResponse.scope,\n                            this.extractRecognizedCustomParameters(tokenResponse)\n                        );\n\n                        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                        resolve(tokenResponse);\n                    },\n                    err => {\n                        this.logger.error('Error performing password flow', err);\n                        this.eventsSubject.next(new OAuthErrorEvent('token_error', err));\n                        reject(err);\n                    }\n                );\n        });\n    }\n\n    /**\n     * Refreshes the token using a refresh_token.\n     * This does not work for implicit flow, b/c\n     * there is no refresh_token in this flow.\n     * A solution for this is provided by the\n     * method silentRefresh.\n     */\n    public refreshToken(): Promise<TokenResponse> {\n        this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n\n        return new Promise((resolve, reject) => {\n            let params = new HttpParams()\n                .set('grant_type', 'refresh_token')\n                .set('scope', this.scope)\n                .set('refresh_token', this._storage.getItem('refresh_token'));\n\n            let headers = new HttpHeaders().set(\n                'Content-Type',\n                'application/x-www-form-urlencoded'\n            );\n\n            if (this.useHttpBasicAuth) {\n                const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n                headers = headers.set(\n                    'Authorization',\n                    'Basic ' + header);\n            }\n\n            if (!this.useHttpBasicAuth) {\n                params = params.set('client_id', this.clientId);\n            }\n\n            if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n                params = params.set('client_secret', this.dummyClientSecret);\n            }\n\n            if (this.customQueryParams) {\n                for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n                    params = params.set(key, this.customQueryParams[key]);\n                }\n            }\n\n            this.http\n                .post<TokenResponse>(this.tokenEndpoint, params, { headers })\n                .pipe(switchMap(tokenResponse => {\n                    if (tokenResponse.id_token) {\n                        return from(this.processIdToken(tokenResponse.id_token, tokenResponse.access_token, true))\n                            .pipe(\n                                tap(result => this.storeIdToken(result)),\n                                map(_ => tokenResponse)\n                            );\n                    } else {\n                        return of(tokenResponse);\n                    }\n                }))\n                .subscribe(\n                    tokenResponse => {\n                        this.debug('refresh tokenResponse', tokenResponse);\n                        this.storeAccessTokenResponse(\n                            tokenResponse.access_token,\n                            tokenResponse.refresh_token,\n                            tokenResponse.expires_in,\n                            tokenResponse.scope,\n                            this.extractRecognizedCustomParameters(tokenResponse)\n                        );\n\n                        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                        this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n                        resolve(tokenResponse);\n                    },\n                    err => {\n                        this.logger.error('Error refreshing token', err);\n                        this.eventsSubject.next(\n                            new OAuthErrorEvent('token_refresh_error', err)\n                        );\n                        reject(err);\n                    }\n                );\n        });\n    }\n\n    protected removeSilentRefreshEventListener(): void {\n        if (this.silentRefreshPostMessageEventListener) {\n            window.removeEventListener(\n                'message',\n                this.silentRefreshPostMessageEventListener\n            );\n            this.silentRefreshPostMessageEventListener = null;\n        }\n    }\n\n    protected setupSilentRefreshEventListener(): void {\n        this.removeSilentRefreshEventListener();\n\n        this.silentRefreshPostMessageEventListener = (e: MessageEvent) => {\n            const message = this.processMessageEventMessage(e);\n\n            this.tryLogin({\n                customHashFragment: message,\n                preventClearHashAfterLogin: true,\n                customRedirectUri: this.silentRefreshRedirectUri || this.redirectUri\n            }).catch(err => this.debug('tryLogin during silent refresh failed', err));\n        };\n\n        window.addEventListener(\n            'message',\n            this.silentRefreshPostMessageEventListener\n        );\n    }\n\n    /**\n     * Performs a silent refresh for implicit flow.\n     * Use this method to get new tokens when/before\n     * the existing tokens expire.\n     */\n    public silentRefresh(params: object = {}, noPrompt = true): Promise<OAuthEvent> {\n        const claims: object = this.getIdentityClaims() || {};\n\n        if (this.useIdTokenHintForSilentRefresh && this.hasValidIdToken()) {\n            params['id_token_hint'] = this.getIdToken();\n        }\n\n        if (!this.validateUrlForHttps(this.loginUrl)) {\n            throw new Error('loginUrl  must use HTTPS (with TLS), or config value for property \\'requireHttps\\' must be set to \\'false\\' and allow HTTP (without TLS).');\n        }\n\n        if (typeof document === 'undefined') {\n            throw new Error('silent refresh is not supported on this platform');\n        }\n\n        const existingIframe = document.getElementById(\n            this.silentRefreshIFrameName\n        );\n\n        if (existingIframe) {\n            document.body.removeChild(existingIframe);\n        }\n\n        this.silentRefreshSubject = claims['sub'];\n\n        const iframe = document.createElement('iframe');\n        iframe.id = this.silentRefreshIFrameName;\n\n        this.setupSilentRefreshEventListener();\n\n        const redirectUri = this.silentRefreshRedirectUri || this.redirectUri;\n        this.createLoginUrl(null, null, redirectUri, noPrompt, params).then(url => {\n            iframe.setAttribute('src', url);\n\n            if (!this.silentRefreshShowIFrame) {\n                iframe.style['display'] = 'none';\n            }\n            document.body.appendChild(iframe);\n        });\n\n        const errors = this.events.pipe(\n            filter(e => e instanceof OAuthErrorEvent),\n            first()\n        );\n        const success = this.events.pipe(\n            filter(e => e.type === 'token_received'),\n            first()\n        );\n        const timeout = of(\n            new OAuthErrorEvent('silent_refresh_timeout', null)\n        ).pipe(delay(this.silentRefreshTimeout));\n\n        return race([errors, success, timeout])\n            .pipe(\n                map(e => {\n                    if (e instanceof OAuthErrorEvent) {\n                        if (e.type === 'silent_refresh_timeout') {\n                            this.eventsSubject.next(e);\n                        } else {\n                            e = new OAuthErrorEvent('silent_refresh_error', e);\n                            this.eventsSubject.next(e);\n                        }\n                        throw e;\n                    } else if (e.type === 'token_received') {\n                        e = new OAuthSuccessEvent('silently_refreshed');\n                        this.eventsSubject.next(e);\n                    }\n                    return e;\n                })\n            )\n            .toPromise();\n    }\n\n    /**\n     * This method exists for backwards compatibility.\n     * {@link OAuthService#initLoginFlowInPopup} handles both code\n     * and implicit flows.\n     */\n    public initImplicitFlowInPopup(options?: { height?: number, width?: number }) {\n        return this.initLoginFlowInPopup(options);\n    }\n\n    public initLoginFlowInPopup(options?: { height?: number, width?: number }) {\n        options = options || {};\n        return this.createLoginUrl(null, null, this.silentRefreshRedirectUri, false, {\n            display: 'popup'\n        }).then(url => {\n            return new Promise((resolve, reject) => {\n                /**\n                 * Error handling section\n                 */\n                const checkForPopupClosedInterval = 500;\n                let windowRef = window.open(url, '_blank', this.calculatePopupFeatures(options));\n                let checkForPopupClosedTimer: any;\n                const checkForPopupClosed = () => {\n                    if (!windowRef || windowRef.closed) {\n                        cleanup();\n                        reject(new OAuthErrorEvent('popup_closed', {}));\n                    }\n                };\n                if (!windowRef) {\n                    reject(new OAuthErrorEvent('popup_blocked', {}));\n                } else {\n                    checkForPopupClosedTimer = window.setInterval(checkForPopupClosed, checkForPopupClosedInterval);\n                }\n\n                const cleanup = () => {\n                    window.clearInterval(checkForPopupClosedTimer);\n                    window.removeEventListener('message', listener);\n                    if (windowRef !== null) {\n                        windowRef.close();\n                    }\n                    windowRef = null;\n                };\n\n                const listener = (e: MessageEvent) => {\n                    const message = this.processMessageEventMessage(e);\n\n                    if (message && message !== null) {\n                        this.tryLogin({\n                            customHashFragment: message,\n                            preventClearHashAfterLogin: true,\n                            customRedirectUri: this.silentRefreshRedirectUri,\n                        }).then(() => {\n                            cleanup();\n                            resolve();\n                        }, err => {\n                            cleanup();\n                            reject(err);\n                        });\n                    } else {\n                        console.log('false event firing');\n                    }\n\n                };\n\n                window.addEventListener('message', listener);\n            });\n        });\n    }\n\n    protected calculatePopupFeatures(options: { height?: number, width?: number }): string {\n        // Specify an static height and width and calculate centered position\n\n        const height = options.height || 470;\n        const width = options.width || 500;\n        const left = window.screenLeft + ((window.outerWidth - width) / 2);\n        const top = window.screenTop + ((window.outerHeight - height) / 2);\n        return `location=no,toolbar=no,width=${width},height=${height},top=${top},left=${left}`;\n    }\n\n    protected processMessageEventMessage(e: MessageEvent): string {\n        let expectedPrefix = '#';\n\n        if (this.silentRefreshMessagePrefix) {\n            expectedPrefix += this.silentRefreshMessagePrefix;\n        }\n\n        if (!e || !e.data || typeof e.data !== 'string') {\n            return;\n        }\n\n        const prefixedMessage: string = e.data;\n\n        if (!prefixedMessage.startsWith(expectedPrefix)) {\n            return;\n        }\n\n        return '#' + prefixedMessage.substr(expectedPrefix.length);\n    }\n\n    protected canPerformSessionCheck(): boolean {\n        if (!this.sessionChecksEnabled) {\n            return false;\n        }\n        if (!this.sessionCheckIFrameUrl) {\n            console.warn(\n                'sessionChecksEnabled is activated but there is no sessionCheckIFrameUrl'\n            );\n            return false;\n        }\n        const sessionState = this.getSessionState();\n        if (!sessionState) {\n            console.warn(\n                'sessionChecksEnabled is activated but there is no session_state'\n            );\n            return false;\n        }\n        if (typeof document === 'undefined') {\n            return false;\n        }\n\n        return true;\n    }\n\n    protected setupSessionCheckEventListener(): void {\n        this.removeSessionCheckEventListener();\n\n        this.sessionCheckEventListener = (e: MessageEvent) => {\n            const origin = e.origin.toLowerCase();\n            const issuer = this.issuer.toLowerCase();\n\n            this.debug('sessionCheckEventListener');\n\n            if (!issuer.startsWith(origin)) {\n                this.debug(\n                    'sessionCheckEventListener',\n                    'wrong origin',\n                    origin,\n                    'expected',\n                    issuer\n                );\n\n                return;\n            }\n\n            // only run in Angular zone if it is 'changed' or 'error'\n            switch (e.data) {\n                case 'unchanged':\n                    this.handleSessionUnchanged();\n                    break;\n                case 'changed':\n                    this.ngZone.run(() => {\n                        this.handleSessionChange();\n                    });\n                    break;\n                case 'error':\n                    this.ngZone.run(() => {\n                        this.handleSessionError();\n                    });\n                    break;\n            }\n\n            this.debug('got info from session check inframe', e);\n        };\n\n        // prevent Angular from refreshing the view on every message (runs in intervals)\n        this.ngZone.runOutsideAngular(() => {\n            window.addEventListener('message', this.sessionCheckEventListener);\n        });\n    }\n\n    protected handleSessionUnchanged(): void {\n        this.debug('session check', 'session unchanged');\n    }\n\n    protected handleSessionChange(): void {\n        /* events: session_changed, relogin, stopTimer, logged_out*/\n        this.eventsSubject.next(new OAuthInfoEvent('session_changed'));\n        this.stopSessionCheckTimer();\n        if (this.silentRefreshRedirectUri) {\n            this.silentRefresh().catch(_ =>\n                this.debug('silent refresh failed after session changed')\n            );\n            this.waitForSilentRefreshAfterSessionChange();\n        } else {\n            this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n            this.logOut(true);\n        }\n    }\n\n    protected waitForSilentRefreshAfterSessionChange(): void {\n        this.events\n            .pipe(\n                filter(\n                    (e: OAuthEvent) =>\n                        e.type === 'silently_refreshed' ||\n                        e.type === 'silent_refresh_timeout' ||\n                        e.type === 'silent_refresh_error'\n                ),\n                first()\n            )\n            .subscribe(e => {\n                if (e.type !== 'silently_refreshed') {\n                    this.debug('silent refresh did not work after session changed');\n                    this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n                    this.logOut(true);\n                }\n            });\n    }\n\n    protected handleSessionError(): void {\n        this.stopSessionCheckTimer();\n        this.eventsSubject.next(new OAuthInfoEvent('session_error'));\n    }\n\n    protected removeSessionCheckEventListener(): void {\n        if (this.sessionCheckEventListener) {\n            window.removeEventListener('message', this.sessionCheckEventListener);\n            this.sessionCheckEventListener = null;\n        }\n    }\n\n    protected initSessionCheck(): void {\n        if (!this.canPerformSessionCheck()) {\n            return;\n        }\n\n        const existingIframe = document.getElementById(this.sessionCheckIFrameName);\n        if (existingIframe) {\n            document.body.removeChild(existingIframe);\n        }\n\n        const iframe = document.createElement('iframe');\n        iframe.id = this.sessionCheckIFrameName;\n\n        this.setupSessionCheckEventListener();\n\n        const url = this.sessionCheckIFrameUrl;\n        iframe.setAttribute('src', url);\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n\n        this.startSessionCheckTimer();\n    }\n\n    protected startSessionCheckTimer(): void {\n        this.stopSessionCheckTimer();\n        this.ngZone.runOutsideAngular(() => {\n            this.sessionCheckTimer = setInterval(\n                this.checkSession.bind(this),\n                this.sessionCheckIntervall\n            );\n        });\n    }\n\n    protected stopSessionCheckTimer(): void {\n        if (this.sessionCheckTimer) {\n            clearInterval(this.sessionCheckTimer);\n            this.sessionCheckTimer = null;\n        }\n    }\n\n    protected checkSession(): void {\n        const iframe: any = document.getElementById(this.sessionCheckIFrameName);\n\n        if (!iframe) {\n            this.logger.warn(\n                'checkSession did not find iframe',\n                this.sessionCheckIFrameName\n            );\n        }\n\n        const sessionState = this.getSessionState();\n\n        if (!sessionState) {\n            this.stopSessionCheckTimer();\n        }\n\n        const message = this.clientId + ' ' + sessionState;\n        iframe.contentWindow.postMessage(message, this.issuer);\n    }\n\n    protected async createLoginUrl(\n        state = '',\n        loginHint = '',\n        customRedirectUri = '',\n        noPrompt = false,\n        params: object = {}\n    ): Promise<string> {\n        const that = this;\n\n        let redirectUri: string;\n\n        if (customRedirectUri) {\n            redirectUri = customRedirectUri;\n        } else {\n            redirectUri = this.redirectUri;\n        }\n\n        const nonce = await this.createAndSaveNonce();\n\n        if (state) {\n            state = nonce + this.config.nonceStateSeparator + state;\n        } else {\n            state = nonce;\n        }\n\n        if (!this.requestAccessToken && !this.oidc) {\n            throw new Error(\n                'Either requestAccessToken or oidc or both must be true'\n            );\n        }\n\n        if (this.config.responseType) {\n            this.responseType = this.config.responseType;\n        } else {\n            if (this.oidc && this.requestAccessToken) {\n                this.responseType = 'id_token token';\n            } else if (this.oidc && !this.requestAccessToken) {\n                this.responseType = 'id_token';\n            } else {\n                this.responseType = 'token';\n            }\n        }\n\n        const seperationChar = that.loginUrl.indexOf('?') > -1 ? '&' : '?';\n\n        let scope = that.scope;\n\n        if (this.oidc && !scope.match(/(^|\\s)openid($|\\s)/)) {\n            scope = 'openid ' + scope;\n        }\n\n        let url =\n            that.loginUrl +\n            seperationChar +\n            'response_type=' +\n            encodeURIComponent(that.responseType) +\n            '&client_id=' +\n            encodeURIComponent(that.clientId) +\n            '&state=' +\n            encodeURIComponent(state) +\n            '&redirect_uri=' +\n            encodeURIComponent(redirectUri) +\n            '&scope=' +\n            encodeURIComponent(scope);\n\n        if (this.responseType === 'code' && !this.disablePKCE) {\n            const [challenge, verifier] = await this.createChallangeVerifierPairForPKCE();\n            this._storage.setItem('PKCI_verifier', verifier);\n            url += '&code_challenge=' + challenge;\n            url += '&code_challenge_method=S256';\n        }\n\n        if (loginHint) {\n            url += '&login_hint=' + encodeURIComponent(loginHint);\n        }\n\n        if (that.resource) {\n            url += '&resource=' + encodeURIComponent(that.resource);\n        }\n\n        if (that.oidc) {\n            url += '&nonce=' + encodeURIComponent(nonce);\n        }\n\n        if (noPrompt) {\n            url += '&prompt=none';\n        }\n\n        for (const key of Object.keys(params)) {\n            url +=\n                '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n        }\n\n        if (this.customQueryParams) {\n            for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n                url +=\n                    '&' + key + '=' + encodeURIComponent(this.customQueryParams[key]);\n            }\n        }\n\n        return url;\n\n    }\n\n    initImplicitFlowInternal(\n        additionalState = '',\n        params: string | object = ''\n    ): void {\n        if (this.inImplicitFlow) {\n            return;\n        }\n\n        this.inImplicitFlow = true;\n\n        if (!this.validateUrlForHttps(this.loginUrl)) {\n            throw new Error(\n                'loginUrl  must use HTTPS (with TLS), or config value for property \\'requireHttps\\' must be set to \\'false\\' and allow HTTP (without TLS).'\n            );\n        }\n\n        let addParams: object = {};\n        let loginHint: string = null;\n\n        if (typeof params === 'string') {\n            loginHint = params;\n        } else if (typeof params === 'object') {\n            addParams = params;\n        }\n\n        this.createLoginUrl(additionalState, loginHint, null, false, addParams)\n            .then(this.config.openUri)\n            .catch(error => {\n                console.error('Error in initImplicitFlow', error);\n                this.inImplicitFlow = false;\n            });\n    }\n\n    /**\n     * Starts the implicit flow and redirects to user to\n     * the auth servers' login url.\n     *\n     * @param additionalState Optional state that is passed around.\n     *  You'll find this state in the property `state` after `tryLogin` logged in the user.\n     * @param params Hash with additional parameter. If it is a string, it is used for the\n     *               parameter loginHint (for the sake of compatibility with former versions)\n     */\n    public initImplicitFlow(\n        additionalState = '',\n        params: string | object = ''\n    ): void {\n        if (this.loginUrl !== '') {\n            this.initImplicitFlowInternal(additionalState, params);\n        } else {\n            this.events\n                .pipe(filter(e => e.type === 'discovery_document_loaded'))\n                .subscribe(_ => this.initImplicitFlowInternal(additionalState, params));\n        }\n    }\n\n    /**\n     * Reset current implicit flow\n     *\n     * @description This method allows resetting the current implict flow in order to be initialized again.\n     */\n    public resetImplicitFlow(): void {\n        this.inImplicitFlow = false;\n    }\n\n    protected callOnTokenReceivedIfExists(options: LoginOptions): void {\n        const that = this;\n        if (options.onTokenReceived) {\n            const tokenParams = {\n                idClaims: that.getIdentityClaims(),\n                idToken: that.getIdToken(),\n                accessToken: that.getAccessToken(),\n                state: that.state\n            };\n            options.onTokenReceived(tokenParams);\n        }\n    }\n\n    protected storeAccessTokenResponse(\n        accessToken: string,\n        refreshToken: string,\n        expiresIn: number,\n        grantedScopes: String,\n        customParameters?: Map<String, String>\n    ): void {\n        this._storage.setItem('access_token', accessToken);\n        if (grantedScopes) {\n            this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split('+')));\n        }\n        this._storage.setItem('access_token_stored_at', '' + Date.now());\n        if (expiresIn) {\n            const expiresInMilliSeconds = expiresIn * 1000;\n            const now = new Date();\n            const expiresAt = now.getTime() + expiresInMilliSeconds;\n            this._storage.setItem('expires_at', '' + expiresAt);\n        }\n\n        if (refreshToken) {\n            this._storage.setItem('refresh_token', refreshToken);\n        }\n        if (customParameters) {\n            customParameters.forEach((value : string, key: string) => {\n              this._storage.setItem(key, value);\n            });\n        }\n    }\n\n    /**\n     * Delegates to tryLoginImplicitFlow for the sake of competability\n     * @param options Optional options.\n     */\n    public tryLogin(options: LoginOptions = null): Promise<boolean> {\n        if (this.config.responseType === 'code') {\n            return this.tryLoginCodeFlow(options).then(_ => true);\n        }\n        else {\n            return this.tryLoginImplicitFlow(options);\n        }\n    }\n\n\n\n    private parseQueryString(queryString: string): object {\n        if (!queryString || queryString.length === 0) {\n            return {};\n        }\n\n        if (queryString.charAt(0) === '?') {\n            queryString = queryString.substr(1);\n        }\n\n        return this.urlHelper.parseQueryString(queryString);\n\n\n    }\n\n    public tryLoginCodeFlow(options: LoginOptions = null): Promise<void> {\n        options = options || {};\n\n        const querySource = options.customHashFragment ?\n            options.customHashFragment.substring(1) :\n            window.location.search;\n\n        const parts = this.getCodePartsFromUrl(window.location.search);\n\n        const code = parts['code'];\n        const state = parts['state'];\n\n        if (!options.preventClearHashAfterLogin) {\n            const href = location.href\n                .replace(/[&\\?]code=[^&\\$]*/, '')\n                .replace(/[&\\?]scope=[^&\\$]*/, '')\n                .replace(/[&\\?]state=[^&\\$]*/, '')\n                .replace(/[&\\?]session_state=[^&\\$]*/, '');\n\n            history.replaceState(null, window.name, href);\n        }\n\n        let [nonceInState, userState] = this.parseState(state);\n        this.state = userState;\n\n        if (parts['error']) {\n            this.debug('error trying to login');\n            this.handleLoginError({}, parts);\n            const err = new OAuthErrorEvent('code_error', {}, parts);\n            this.eventsSubject.next(err);\n            return Promise.reject(err);\n        }\n\n        if (!nonceInState) {\n            return Promise.resolve();\n        }\n\n        const success = this.validateNonce(nonceInState);\n        if (!success) {\n            const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n            this.eventsSubject.next(event);\n            return Promise.reject(event);\n        }\n\n        if (code) {\n            return new Promise((resolve, reject) => {\n                this.getTokenFromCode(code, options).then(result => {\n                    resolve();\n                }).catch(err => {\n                    reject(err);\n                });\n            });\n        } else {\n            return Promise.resolve();\n        }\n    }\n\n    /**\n    * Retrieve the returned auth code from the redirect uri that has been called.\n    * If required also check hash, as we could use hash location strategy.\n    */\n    private getCodePartsFromUrl(queryString: string): object {\n        if (!queryString || queryString.length === 0) {\n            return this.urlHelper.getHashFragmentParams();\n        }\n\n        // normalize query string\n        if (queryString.charAt(0) === '?') {\n            queryString = queryString.substr(1);\n        }\n\n        return this.urlHelper.parseQueryString(queryString);\n    }\n\n    /**\n     * Get token using an intermediate code. Works for the Authorization Code flow.\n     */\n    private getTokenFromCode(code: string, options: LoginOptions): Promise<object> {\n        let params = new HttpParams()\n            .set('grant_type', 'authorization_code')\n            .set('code', code)\n            .set('redirect_uri', options.customRedirectUri || this.redirectUri);\n\n        if (!this.disablePKCE) {\n            const pkciVerifier = this._storage.getItem('PKCI_verifier');\n\n            if (!pkciVerifier) {\n                console.warn('No PKCI verifier found in oauth storage!');\n            } else {\n                params = params.set('code_verifier', pkciVerifier);\n            }\n        }\n\n        return this.fetchAndProcessToken(params);\n    }\n\n    private fetchAndProcessToken(params: HttpParams): Promise<TokenResponse> {\n\n        this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n        let headers = new HttpHeaders()\n            .set('Content-Type', 'application/x-www-form-urlencoded');\n\n        if (this.useHttpBasicAuth) {\n            const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n            headers = headers.set(\n                'Authorization',\n                'Basic ' + header);\n        }\n\n        if (!this.useHttpBasicAuth) {\n            params = params.set('client_id', this.clientId);\n        }\n\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n            params = params.set('client_secret', this.dummyClientSecret);\n        }\n\n        return new Promise((resolve, reject) => {\n\n            if (this.customQueryParams) {\n                for (let key of Object.getOwnPropertyNames(this.customQueryParams)) {\n                    params = params.set(key, this.customQueryParams[key]);\n                }\n            }\n\n            this.http.post<TokenResponse>(this.tokenEndpoint, params, { headers }).subscribe(\n                (tokenResponse) => {\n                    this.debug('refresh tokenResponse', tokenResponse);\n                    this.storeAccessTokenResponse(\n                        tokenResponse.access_token,\n                        tokenResponse.refresh_token,\n                        tokenResponse.expires_in,\n                        tokenResponse.scope,\n                        this.extractRecognizedCustomParameters(tokenResponse));\n\n                    if (this.oidc && tokenResponse.id_token) {\n                        this.processIdToken(tokenResponse.id_token, tokenResponse.access_token).\n                            then(result => {\n                                this.storeIdToken(result);\n\n                                this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                                this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n\n                                resolve(tokenResponse);\n                            })\n                            .catch(reason => {\n                                this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n                                console.error('Error validating tokens');\n                                console.error(reason);\n\n                                reject(reason);\n                            });\n                    } else {\n                        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                        this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n\n                        resolve(tokenResponse);\n                    }\n                },\n                (err) => {\n                    console.error('Error getting token', err);\n                    this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n                    reject(err);\n                }\n            );\n        });\n    }\n\n    /**\n     * Checks whether there are tokens in the hash fragment\n     * as a result of the implicit flow. These tokens are\n     * parsed, validated and used to sign the user in to the\n     * current client.\n     *\n     * @param options Optional options.\n     */\n    public tryLoginImplicitFlow(options: LoginOptions = null): Promise<boolean> {\n        options = options || {};\n\n        let parts: object;\n\n        if (options.customHashFragment) {\n            parts = this.urlHelper.getHashFragmentParams(options.customHashFragment);\n        } else {\n            parts = this.urlHelper.getHashFragmentParams();\n        }\n\n        this.debug('parsed url', parts);\n\n        const state = parts['state'];\n\n        let [nonceInState, userState] = this.parseState(state);\n        this.state = userState;\n\n        if (parts['error']) {\n            this.debug('error trying to login');\n            this.handleLoginError(options, parts);\n            const err = new OAuthErrorEvent('token_error', {}, parts);\n            this.eventsSubject.next(err);\n            return Promise.reject(err);\n        }\n\n        const accessToken = parts['access_token'];\n        const idToken = parts['id_token'];\n        const sessionState = parts['session_state'];\n        const grantedScopes = parts['scope'];\n\n        if (!this.requestAccessToken && !this.oidc) {\n            return Promise.reject(\n                'Either requestAccessToken or oidc (or both) must be true.'\n            );\n        }\n\n        if (this.requestAccessToken && !accessToken) {\n            return Promise.resolve(false);\n        }\n        if (this.requestAccessToken && !options.disableOAuth2StateCheck && !state) {\n            return Promise.resolve(false);\n        }\n        if (this.oidc && !idToken) {\n            return Promise.resolve(false);\n        }\n\n        if (this.sessionChecksEnabled && !sessionState) {\n            this.logger.warn(\n                'session checks (Session Status Change Notification) ' +\n                'were activated in the configuration but the id_token ' +\n                'does not contain a session_state claim'\n            );\n        }\n\n        if (this.requestAccessToken && !options.disableOAuth2StateCheck) {\n            const success = this.validateNonce(nonceInState);\n\n            if (!success) {\n                const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n                this.eventsSubject.next(event);\n                return Promise.reject(event);\n            }\n        }\n\n        if (this.requestAccessToken) {\n            this.storeAccessTokenResponse(\n                accessToken,\n                null,\n                parts['expires_in'] || this.fallbackAccessTokenExpirationTimeInSec,\n                grantedScopes\n            );\n        }\n\n        if (!this.oidc) {\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n            if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n                location.hash = '';\n            }\n\n            this.callOnTokenReceivedIfExists(options);\n            return Promise.resolve(true);\n\n        }\n\n        return this.processIdToken(idToken, accessToken)\n            .then(result => {\n                if (options.validationHandler) {\n                    return options\n                        .validationHandler({\n                            accessToken: accessToken,\n                            idClaims: result.idTokenClaims,\n                            idToken: result.idToken,\n                            state: state\n                        })\n                        .then(_ => result);\n                }\n                return result;\n            })\n            .then(result => {\n                this.storeIdToken(result);\n                this.storeSessionState(sessionState);\n                if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n                    location.hash = '';\n                }\n                this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                this.callOnTokenReceivedIfExists(options);\n                this.inImplicitFlow = false;\n                return true;\n            })\n            .catch(reason => {\n                this.eventsSubject.next(\n                    new OAuthErrorEvent('token_validation_error', reason)\n                );\n                this.logger.error('Error validating tokens');\n                this.logger.error(reason);\n                return Promise.reject(reason);\n            });\n    }\n\n    private parseState(state: string): [string, string] {\n        let nonce = state;\n        let userState = '';\n\n        if (state) {\n            const idx = state.indexOf(this.config.nonceStateSeparator);\n            if (idx > -1) {\n                nonce = state.substr(0, idx);\n                userState = state.substr(idx + this.config.nonceStateSeparator.length);\n            }\n        }\n        return [nonce, userState];\n    }\n\n    protected validateNonce(\n        nonceInState: string\n    ): boolean {\n        const savedNonce = this._storage.getItem('nonce');\n        if (savedNonce !== nonceInState) {\n\n            const err = 'Validating access_token failed, wrong state/nonce.';\n            console.error(err, savedNonce, nonceInState);\n            return false;\n        }\n        return true;\n    }\n\n    protected storeIdToken(idToken: ParsedIdToken): void {\n        this._storage.setItem('id_token', idToken.idToken);\n        this._storage.setItem('id_token_claims_obj', idToken.idTokenClaimsJson);\n        this._storage.setItem('id_token_expires_at', '' + idToken.idTokenExpiresAt);\n        this._storage.setItem('id_token_stored_at', '' + Date.now());\n    }\n\n    protected storeSessionState(sessionState: string): void {\n        this._storage.setItem('session_state', sessionState);\n    }\n\n    protected getSessionState(): string {\n        return this._storage.getItem('session_state');\n    }\n\n    protected handleLoginError(options: LoginOptions, parts: object): void {\n        if (options.onLoginError) {\n            options.onLoginError(parts);\n        }\n        if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n            location.hash = '';\n        }\n    }\n\n    /**\n     * @ignore\n     */\n    public processIdToken(\n        idToken: string,\n        accessToken: string,\n        skipNonceCheck = false\n    ): Promise<ParsedIdToken> {\n        const tokenParts = idToken.split('.');\n        const headerBase64 = this.padBase64(tokenParts[0]);\n        const headerJson = b64DecodeUnicode(headerBase64);\n        const header = JSON.parse(headerJson);\n        const claimsBase64 = this.padBase64(tokenParts[1]);\n        const claimsJson = b64DecodeUnicode(claimsBase64);\n        const claims = JSON.parse(claimsJson);\n        const savedNonce = this._storage.getItem('nonce');\n\n        if (Array.isArray(claims.aud)) {\n            if (claims.aud.every(v => v !== this.clientId)) {\n                const err = 'Wrong audience: ' + claims.aud.join(',');\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n        } else {\n            if (claims.aud !== this.clientId) {\n                const err = 'Wrong audience: ' + claims.aud;\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n        }\n\n        if (!claims.sub) {\n            const err = 'No sub claim in id_token';\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n\n        /* For now, we only check whether the sub against\n         * silentRefreshSubject when sessionChecksEnabled is on\n         * We will reconsider in a later version to do this\n         * in every other case too.\n         */\n        if (\n            this.sessionChecksEnabled &&\n            this.silentRefreshSubject &&\n            this.silentRefreshSubject !== claims['sub']\n        ) {\n            const err =\n                'After refreshing, we got an id_token for another user (sub). ' +\n                `Expected sub: ${this.silentRefreshSubject}, received sub: ${\n                claims['sub']\n                }`;\n\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n\n        if (!claims.iat) {\n            const err = 'No iat claim in id_token';\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n\n        if (!this.skipIssuerCheck && claims.iss !== this.issuer) {\n            const err = 'Wrong issuer: ' + claims.iss;\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n\n        if (!skipNonceCheck && claims.nonce !== savedNonce) {\n            const err = 'Wrong nonce: ' + claims.nonce;\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n        // at_hash is not applicable to authorization code flow\n        // addressing https://github.com/manfredsteyer/angular-oauth2-oidc/issues/661\n        // i.e. Based on spec the at_hash check is only true for implicit code flow on Ping Federate\n        // https://www.pingidentity.com/developer/en/resources/openid-connect-developers-guide.html\n        if (this.hasOwnProperty('responseType') && this.responseType === 'code') {\n            this.disableAtHashCheck = true;\n        }\n        if (\n            !this.disableAtHashCheck &&\n            this.requestAccessToken &&\n            !claims['at_hash']\n        ) {\n            const err = 'An at_hash is needed!';\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n\n        const now = Date.now();\n        const issuedAtMSec = claims.iat * 1000;\n        const expiresAtMSec = claims.exp * 1000;\n        const clockSkewInMSec = (this.clockSkewInSec || 600) * 1000;\n\n        if (\n            issuedAtMSec - clockSkewInMSec >= now ||\n            expiresAtMSec + clockSkewInMSec <= now\n        ) {\n            const err = 'Token has expired';\n            console.error(err);\n            console.error({\n                now: now,\n                issuedAtMSec: issuedAtMSec,\n                expiresAtMSec: expiresAtMSec\n            });\n            return Promise.reject(err);\n        }\n\n        const validationParams: ValidationParams = {\n            accessToken: accessToken,\n            idToken: idToken,\n            jwks: this.jwks,\n            idTokenClaims: claims,\n            idTokenHeader: header,\n            loadKeys: () => this.loadJwks()\n        };\n\n        if (this.disableAtHashCheck) {\n            return this.checkSignature(validationParams).then(_ => {\n                const result: ParsedIdToken = {\n                    idToken: idToken,\n                    idTokenClaims: claims,\n                    idTokenClaimsJson: claimsJson,\n                    idTokenHeader: header,\n                    idTokenHeaderJson: headerJson,\n                    idTokenExpiresAt: expiresAtMSec\n                };\n                return result;\n            });\n        }\n\n        return this.checkAtHash(validationParams)\n            .then(atHashValid => {\n                if (\n                    !this.disableAtHashCheck &&\n                    this.requestAccessToken &&\n                    !atHashValid\n                ) {\n                    const err = 'Wrong at_hash';\n                    this.logger.warn(err);\n                    return Promise.reject(err);\n                }\n\n                return this.checkSignature(validationParams).then(_ => {\n                    const atHashCheckEnabled = !this.disableAtHashCheck;\n                    const result: ParsedIdToken = {\n                        idToken: idToken,\n                        idTokenClaims: claims,\n                        idTokenClaimsJson: claimsJson,\n                        idTokenHeader: header,\n                        idTokenHeaderJson: headerJson,\n                        idTokenExpiresAt: expiresAtMSec\n                    };\n                    if (atHashCheckEnabled) {\n                        return this.checkAtHash(validationParams).then(atHashValid => {\n                            if (this.requestAccessToken && !atHashValid) {\n                                const err = 'Wrong at_hash';\n                                this.logger.warn(err);\n                                return Promise.reject(err);\n                            } else {\n                                return result;\n                            }\n                        });\n                    } else {\n                        return result;\n                    }\n                });\n            });\n    }\n\n    /**\n     * Returns the received claims about the user.\n     */\n    public getIdentityClaims(): object {\n        const claims = this._storage.getItem('id_token_claims_obj');\n        if (!claims) {\n            return null;\n        }\n        return JSON.parse(claims);\n    }\n\n    /**\n     * Returns the granted scopes from the server.\n     */\n    public getGrantedScopes(): object {\n        const scopes = this._storage.getItem('granted_scopes');\n        if (!scopes) {\n            return null;\n        }\n        return JSON.parse(scopes);\n    }\n\n    /**\n     * Returns the current id_token.\n     */\n    public getIdToken(): string {\n        return this._storage\n            ? this._storage.getItem('id_token')\n            : null;\n    }\n\n    protected padBase64(base64data): string {\n        while (base64data.length % 4 !== 0) {\n            base64data += '=';\n        }\n        return base64data;\n    }\n\n    /**\n     * Returns the current access_token.\n     */\n    public getAccessToken(): string {\n        return this._storage\n            ? this._storage.getItem('access_token')\n            : null;\n    }\n\n    public getRefreshToken(): string {\n        return this._storage\n            ? this._storage.getItem('refresh_token')\n            : null;\n    }\n\n    /**\n     * Returns the expiration date of the access_token\n     * as milliseconds since 1970.\n     */\n    public getAccessTokenExpiration(): number {\n        if (!this._storage.getItem('expires_at')) {\n            return null;\n        }\n        return parseInt(this._storage.getItem('expires_at'), 10);\n    }\n\n    protected getAccessTokenStoredAt(): number {\n        return parseInt(this._storage.getItem('access_token_stored_at'), 10);\n    }\n\n    protected getIdTokenStoredAt(): number {\n        return parseInt(this._storage.getItem('id_token_stored_at'), 10);\n    }\n\n    /**\n     * Returns the expiration date of the id_token\n     * as milliseconds since 1970.\n     */\n    public getIdTokenExpiration(): number {\n        if (!this._storage.getItem('id_token_expires_at')) {\n            return null;\n        }\n\n        return parseInt(this._storage.getItem('id_token_expires_at'), 10);\n    }\n\n    /**\n     * Checkes, whether there is a valid access_token.\n     */\n    public hasValidAccessToken(): boolean {\n        if (this.getAccessToken()) {\n            const expiresAt = this._storage.getItem('expires_at');\n            const now = new Date();\n            if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether there is a valid id_token.\n     */\n    public hasValidIdToken(): boolean {\n        if (this.getIdToken()) {\n            const expiresAt = this._storage.getItem('id_token_expires_at');\n            const now = new Date();\n            if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Retrieve a saved custom property of the TokenReponse object. Only if predefined in authconfig.\n     */\n    public getCustomTokenResponseProperty(requestedProperty: string): any {\n      return this._storage && this.config.customTokenParameters\n          && (this.config.customTokenParameters.indexOf(requestedProperty) >= 0)\n            && this._storage.getItem(requestedProperty) !== null\n            ? JSON.parse(this._storage.getItem(requestedProperty)) : null;\n    }\n\n    /**\n     * Returns the auth-header that can be used\n     * to transmit the access_token to a service\n     */\n    public authorizationHeader(): string {\n        return 'Bearer ' + this.getAccessToken();\n    }\n\n    /**\n     * Removes all tokens and logs the user out.\n     * If a logout url is configured, the user is\n     * redirected to it.\n     * @param noRedirectToLogoutUrl\n     */\n    public logOut(noRedirectToLogoutUrl = false): void {\n        const id_token = this.getIdToken();\n        this._storage.removeItem('access_token');\n        this._storage.removeItem('id_token');\n        this._storage.removeItem('refresh_token');\n        this._storage.removeItem('nonce');\n        this._storage.removeItem('expires_at');\n        this._storage.removeItem('id_token_claims_obj');\n        this._storage.removeItem('id_token_expires_at');\n        this._storage.removeItem('id_token_stored_at');\n        this._storage.removeItem('access_token_stored_at');\n        this._storage.removeItem('granted_scopes');\n        this._storage.removeItem('session_state');\n        if (this.config.customTokenParameters) {\n          this.config.customTokenParameters.forEach(customParam => this._storage.removeItem(customParam));\n        }\n        this.silentRefreshSubject = null;\n\n        this.eventsSubject.next(new OAuthInfoEvent('logout'));\n\n        if (!this.logoutUrl) {\n            return;\n        }\n        if (noRedirectToLogoutUrl) {\n            return;\n        }\n\n        if (!id_token && !this.postLogoutRedirectUri) {\n            return;\n        }\n\n        let logoutUrl: string;\n\n        if (!this.validateUrlForHttps(this.logoutUrl)) {\n            throw new Error(\n                'logoutUrl  must use HTTPS (with TLS), or config value for property \\'requireHttps\\' must be set to \\'false\\' and allow HTTP (without TLS).'\n            );\n        }\n\n        // For backward compatibility\n        if (this.logoutUrl.indexOf('{{') > -1) {\n            logoutUrl = this.logoutUrl\n                .replace(/\\{\\{id_token\\}\\}/, id_token)\n                .replace(/\\{\\{client_id\\}\\}/, this.clientId);\n        } else {\n\n            let params = new HttpParams();\n\n            if (id_token) {\n                params = params.set('id_token_hint', id_token);\n            }\n\n            const postLogoutUrl = this.postLogoutRedirectUri || this.redirectUri;\n            if (postLogoutUrl) {\n                params = params.set('post_logout_redirect_uri', postLogoutUrl);\n            }\n\n            logoutUrl =\n                this.logoutUrl +\n                (this.logoutUrl.indexOf('?') > -1 ? '&' : '?') +\n                params.toString();\n        }\n        this.config.openUri(logoutUrl);\n    }\n\n    /**\n     * @ignore\n     */\n    public createAndSaveNonce(): Promise<string> {\n        const that = this;\n        return this.createNonce().then(function (nonce: any) {\n            that._storage.setItem('nonce', nonce);\n            return nonce;\n        });\n    }\n\n    /**\n     * @ignore\n     */\n    public ngOnDestroy(): void {\n        this.clearAccessTokenTimer();\n        this.clearIdTokenTimer();\n\n        this.removeSilentRefreshEventListener();\n        const silentRefreshFrame = document.getElementById(this.silentRefreshIFrameName);\n        if (silentRefreshFrame) {\n            silentRefreshFrame.remove();\n        }\n\n        this.stopSessionCheckTimer();\n        this.removeSessionCheckEventListener();\n        const sessionCheckFrame = document.getElementById(this.sessionCheckIFrameName);\n        if (sessionCheckFrame) {\n            sessionCheckFrame.remove();\n        }\n    }\n\n    protected createNonce(): Promise<string> {\n        return new Promise((resolve) => {\n            if (this.rngUrl) {\n                throw new Error(\n                    'createNonce with rng-web-api has not been implemented so far'\n                );\n            }\n\n            /*\n             * This alphabet is from:\n             * https://tools.ietf.org/html/rfc7636#section-4.1\n             *\n             * [A-Z] / [a-z] / [0-9] / \"-\" / \".\" / \"_\" / \"~\"\n             */\n            const unreserved = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n            let size = 45;\n            let id = '';\n\n            const crypto = typeof self === 'undefined' ? null : (self.crypto || self['msCrypto']);\n            if (crypto) {\n                let bytes = new Uint8Array(size);\n                crypto.getRandomValues(bytes);\n                bytes = bytes.map(x => unreserved.charCodeAt(x % unreserved.length));\n                id = String.fromCharCode.apply(null, bytes);\n            } else {\n                while (0 < size--) {\n                    id += unreserved[Math.random() * unreserved.length | 0];\n                }\n            }\n\n            resolve(base64UrlEncode(id));\n        });\n    }\n\n    protected async checkAtHash(params: ValidationParams): Promise<boolean> {\n        if (!this.tokenValidationHandler) {\n            this.logger.warn(\n                'No tokenValidationHandler configured. Cannot check at_hash.'\n            );\n            return true;\n        }\n        return this.tokenValidationHandler.validateAtHash(params);\n    }\n\n    protected checkSignature(params: ValidationParams): Promise<any> {\n        if (!this.tokenValidationHandler) {\n            this.logger.warn(\n                'No tokenValidationHandler configured. Cannot check signature.'\n            );\n            return Promise.resolve(null);\n        }\n        return this.tokenValidationHandler.validateSignature(params);\n    }\n\n\n    /**\n     * Start the implicit flow or the code flow,\n     * depending on your configuration.\n     */\n    public initLoginFlow(\n        additionalState = '',\n        params = {}\n    ): void {\n        if (this.responseType === 'code') {\n            return this.initCodeFlow(additionalState, params);\n        } else {\n            return this.initImplicitFlow(additionalState, params);\n        }\n    }\n\n    /**\n     * Starts the authorization code flow and redirects to user to\n     * the auth servers login url.\n     */\n    public initCodeFlow(\n        additionalState = '',\n        params = {}\n    ): void {\n        if (this.loginUrl !== '') {\n            this.initCodeFlowInternal(additionalState, params);\n        } else {\n            this.events.pipe(filter(e => e.type === 'discovery_document_loaded'))\n                .subscribe(_ => this.initCodeFlowInternal(additionalState, params));\n        }\n    }\n\n    private initCodeFlowInternal(\n        additionalState = '',\n        params = {}\n    ): void {\n\n        if (!this.validateUrlForHttps(this.loginUrl)) {\n            throw new Error('loginUrl  must use HTTPS (with TLS), or config value for property \\'requireHttps\\' must be set to \\'false\\' and allow HTTP (without TLS).');\n        }\n\n        this.createLoginUrl(additionalState, '', null, false, params)\n            .then(this.config.openUri)\n            .catch(error => {\n                console.error('Error in initAuthorizationCodeFlow');\n                console.error(error);\n            });\n    }\n\n    protected async createChallangeVerifierPairForPKCE(): Promise<[string, string]> {\n\n        if (!this.crypto) {\n            throw new Error('PKCI support for code flow needs a CryptoHander. Did you import the OAuthModule using forRoot() ?');\n        }\n\n\n        const verifier = await this.createNonce();\n        const challengeRaw = await this.crypto.calcHash(verifier, 'sha-256');\n        const challenge = base64UrlEncode(challengeRaw);\n\n        return [challenge, verifier];\n    }\n\n    private extractRecognizedCustomParameters(tokenResponse: TokenResponse): Map<String, String> {\n      let foundParameters: Map<String, String> = new Map<String, String>();\n      if (!this.config.customTokenParameters) {\n        return foundParameters;\n      }\n      this.config.customTokenParameters.forEach((recognizedParameter: string) => {\n          if (tokenResponse[recognizedParameter]) {\n            foundParameters.set(recognizedParameter, JSON.stringify(tokenResponse[recognizedParameter]));\n          }\n      });\n      return foundParameters;\n    }\n}\n","export abstract class OAuthModuleConfig {\n  resourceServer: OAuthResourceServerConfig;\n}\n\nexport abstract class OAuthResourceServerConfig {\n  /**\n   * Urls for which calls should be intercepted.\n   * If there is an ResourceServerErrorHandler registered, it is used for them.\n   * If sendAccessToken is set to true, the access_token is send to them too.\n   */\n  allowedUrls?: Array<string>;\n  sendAccessToken: boolean;\n  customUrlValidation?: (url: string) => boolean;\n}\n","import { HttpResponse } from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\n\nexport abstract class OAuthResourceServerErrorHandler {\n  abstract handleError(err: HttpResponse<any>): Observable<any>;\n}\n\nexport class OAuthNoopResourceServerErrorHandler\n  implements OAuthResourceServerErrorHandler {\n  handleError(err: HttpResponse<any>): Observable<any> {\n    return throwError(err);\n  }\n}\n","import { Injectable, Optional } from '@angular/core';\n\nimport {\n  HttpEvent,\n  HttpHandler,\n  HttpInterceptor,\n  HttpRequest,\n} from '@angular/common/http';\nimport { Observable, of, merge } from 'rxjs';\nimport { catchError, filter, map, take, mergeMap, timeout } from 'rxjs/operators';\nimport { OAuthResourceServerErrorHandler } from './resource-server-error-handler';\nimport { OAuthModuleConfig } from '../oauth-module.config';\nimport { OAuthStorage } from '../types';\nimport { OAuthService } from '../oauth-service';\n\n@Injectable()\nexport class DefaultOAuthInterceptor implements HttpInterceptor {\n\n    constructor(\n        private authStorage: OAuthStorage,\n        private oAuthService: OAuthService,\n        private errorHandler: OAuthResourceServerErrorHandler,\n        @Optional() private moduleConfig: OAuthModuleConfig\n    ) { }\n\n    private checkUrl(url: string): boolean {\n        if (this.moduleConfig.resourceServer.customUrlValidation) {\n            return this.moduleConfig.resourceServer.customUrlValidation(url);\n        }\n\n        if (this.moduleConfig.resourceServer.allowedUrls) {\n            return !!this.moduleConfig.resourceServer.allowedUrls.find(u => url.startsWith(u));\n        }\n\n        return true;\n    }\n\n  public intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const url = req.url.toLowerCase();\n\n\n    if (!this.moduleConfig || !this.moduleConfig.resourceServer || !this.checkUrl(url)) {\n      return next.handle(req);\n    }\n\n    const sendAccessToken = this.moduleConfig.resourceServer.sendAccessToken;\n\n    if (!sendAccessToken) {\n      return next\n        .handle(req)\n        .pipe(catchError(err => this.errorHandler.handleError(err)));\n    }\n\n    return merge(\n      of(this.oAuthService.getAccessToken()).pipe(\n        filter(token => token ? true : false),\n      ),\n      this.oAuthService.events.pipe(\n        filter(e => e.type === 'token_received'),\n        timeout(this.oAuthService.waitForTokenInMsec || 0),\n        catchError(_ => of(null)), // timeout is not an error\n        map(_ => this.oAuthService.getAccessToken()),\n      ),\n    ).pipe(\n      take(1),\n      mergeMap(token => {\n        if (token) {\n          const header = 'Bearer ' + token;\n          const headers = req.headers.set('Authorization', header);\n          req = req.clone({ headers });\n        }\n\n        return next\n          .handle(req)\n          .pipe(catchError(err => this.errorHandler.handleError(err)));\n      }),\n    );\n  }\n}\n","import { ValidationHandler, ValidationParams } from './validation-handler';\n\n/**\n * A validation handler that isn't validating nothing.\n * Can be used to skip validation (at your own risk).\n */\nexport class NullValidationHandler implements ValidationHandler {\n  validateSignature(validationParams: ValidationParams): Promise<any> {\n    return Promise.resolve(null);\n  }\n  validateAtHash(validationParams: ValidationParams): Promise<boolean> {\n    return Promise.resolve(true);\n  }\n}\n","import { MemoryStorage } from './types';\n\nexport function createDefaultLogger() {\n    return console;\n}\n\nexport function createDefaultStorage() {\n    return typeof sessionStorage !== 'undefined' ? sessionStorage : new MemoryStorage();\n}","import { OAuthStorage, OAuthLogger } from './types';\nimport { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nimport { OAuthService } from './oauth-service';\nimport { UrlHelperService } from './url-helper.service';\n\nimport { OAuthModuleConfig } from './oauth-module.config';\nimport {\n  OAuthResourceServerErrorHandler,\n  OAuthNoopResourceServerErrorHandler\n} from './interceptors/resource-server-error-handler';\nimport { DefaultOAuthInterceptor } from './interceptors/default-oauth.interceptor';\nimport { ValidationHandler } from './token-validation/validation-handler';\nimport { NullValidationHandler } from './token-validation/null-validation-handler';\nimport { createDefaultLogger, createDefaultStorage } from './factories';\nimport { HashHandler, DefaultHashHandler } from './token-validation/hash-handler';\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [],\n  exports: []\n})\nexport class OAuthModule {\n  static forRoot(\n    config: OAuthModuleConfig = null,\n    validationHandlerClass = NullValidationHandler\n  ): ModuleWithProviders<OAuthModule> {\n    return {\n      ngModule: OAuthModule,\n      providers: [\n        OAuthService,\n        UrlHelperService,\n        { provide: OAuthLogger, useFactory: createDefaultLogger },\n        { provide: OAuthStorage, useFactory: createDefaultStorage },\n        { provide: ValidationHandler, useClass: validationHandlerClass},\n        { provide: HashHandler, useClass: DefaultHashHandler },\n        {\n          provide: OAuthResourceServerErrorHandler,\n          useClass: OAuthNoopResourceServerErrorHandler\n        },\n        { provide: OAuthModuleConfig, useValue: config },\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: DefaultOAuthInterceptor,\n          multi: true\n        }\n      ]\n    };\n  }\n}\n","import { NullValidationHandler } from './null-validation-handler';\n\nconst err = `PLEASE READ THIS CAREFULLY:\n\nBeginning with angular-oauth2-oidc version 9, the JwksValidationHandler\nhas been moved to an library of its own. If you need it for implementing\nOAuth2/OIDC **implicit flow**, please install it using npm:\n\n  npm i angular-oauth2-oidc-jwks --save\n\nAfter that, you can import it into your application:\n\n  import { JwksValidationHandler } from 'angular-oauth2-oidc-jwks';\n\nPlease note, that this dependency is not needed for the **code flow**,\nwhich is nowadays the **recommented** one for single page applications.\nThis also results in smaller bundle sizes.\n`;\n\n/**\n * This is just a dummy of the JwksValidationHandler\n * telling the users that the real one has been moved\n * to an library of its own, namely angular-oauth2-oidc-utils\n */\nexport class JwksValidationHandler extends NullValidationHandler {\n\n  constructor() {\n    super();\n    console.error(err);\n  }\n\n}","import { InjectionToken } from '@angular/core';\nimport { AuthConfig } from './auth.config';\n\nexport const AUTH_CONFIG = new InjectionToken<AuthConfig>('AUTH_CONFIG');\n"]}